<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta name="renderer" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>硕博士论文检测报告（全文比对）</title>

    <link href="./Report(该文件夹请勿删除影响报告阅读)/bootstrap.css" rel="stylesheet">
    <link href="./Report(该文件夹请勿删除影响报告阅读)/report.css" rel="stylesheet">
    <link href="./Report(该文件夹请勿删除影响报告阅读)/components.css" rel="stylesheet">
    <!--[if lt IE 9]>
      <script src="//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style>
        #part1 .row {
            margin-bottom: 3px;
        }

        #checkrangelist {
            float: left;
            width: 660px;
        }

            #checkrangelist div {
                width: 220px;
                float: left;
                height: 25px;
            }

        #bar1 {
            margin: auto;
            width: 800px;
            position: relative;
            height: 110px;
        }


        .bg-hover {
            background-color: silver;
        }

        .tick {
            width: 1px;
            height: 15px;
            background-color: #3FCBDB;
            position: absolute;
        }

        .ticktext {
            /*height: 20px;*/
            /*color: #3FCBDB;*/
            position: absolute;
            font-size: 14px;
        }

        .block {
            position: absolute;
            top: 2px;
        }

        .small-rect {
            width: 12px;
            height: 12px;
            border: 1px;
            display: inline-block;
            margin: 0 3px;
        }

        .block-hover {
            border: solid 1px red;
        }

        body {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>

    <script>
        var app = { Setting: { DomainConfig: {} } };
        app.root = './report/';

    </script>
    <script>
        /* 兼容IE8 Array.indexOf */
        Array.prototype.indexOf = function (item) {
            return _.indexOf(this, item);
        };
    </script>
    <script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="text" src="./Report(该文件夹请勿删除影响报告阅读)/text.js"></script>
    <script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="knockout" src="./Report(该文件夹请勿删除影响报告阅读)/knockout-3.4.0.js"></script>
</head>
<body>
    <!-- 头部 -->
    <div class="header" style="background-color:white;">
        <div class="container" style="height:82px;">
            <img src="./Report(该文件夹请勿删除影响报告阅读)/logo.png" style="margin: 25px 0 15px 70px;height:42px;">
        </div>
    </div>

    <!-- 主要 -->
    <div class="report-wrapper">
        <div class="report-container">
            <!-- 报告头部 -->
            <div class="report-header">
                <div class="title">硕博士论文检测报告（全文比对）</div>
                <hr class="hr-header">
            </div>

            <!-- 报告主体 -->
            <div class="report-body">
                <!-- 1、报告属性 -->
                <div id="part1" class="section" style="background-color:#f4feff;">
                    <div style="padding:15px 0">
                        <div class="row">
                            <div class="col-md-5 col-md-offset-1">
                                <label>报告编号：</label><span>PL-20200422-4C3C0629-QW</span>
                            </div>
                            <div class="col-md-5 col-md-offset-1">
                                <label>检测时间：</label><span>2020-04-22 17:20:30</span>
                            </div>
                            <div class="col-md-5 col-md-offset-1">
                                <label>题　　名：</label><span>基于深度学习的程序并行化方法研究</span>
                            </div>

                            <div class="col-md-5 col-md-offset-1">
                                <label>作　　者：</label><span>王世领</span>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-10 col-md-offset-1">
                                <label style="float:left;">检测范围：</label>
                                <div id="checkrangelist">
                                    <div>
                                        <input type="checkbox" checked="checked" disabled="">中国学术期刊数据库
                                    </div>
                                    <div>
                                        <input type="checkbox" checked="checked" disabled="">中国学位论文全文数据库
                                    </div>
                                    <div>
                                        <input type="checkbox" checked="checked" disabled="">中国学术会议论文数据库
                                    </div>
                                    <div>
                                        <input type="checkbox" checked="checked" disabled="">中国学术网页数据库
                                    </div>
                                    <div>
                                        <input type="checkbox" checked="checked" disabled="">中国专利文献数据库
                                    </div>
                                    <div>
                                        <input type="checkbox" checked="checked" disabled="">中国优秀报纸数据库
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="part2">
                    <h2>总相似比：<span style="color:red;" data-bind="text: copyPercentGraph() + '%'"></span></h2>
                    <div style="font-size:13px;">
                        <div class="row" style="height:24px;">
                            <div class="col-md-4 col-md-offset-2">检测字数：<strong data-bind="numeral: originalCharacterTotal"></strong></div>
                            <div class="col-md-4"></div>
                        </div>
                        <div class="row" style="height:24px;">
                            <div class="col-md-4 col-md-offset-2">参考文献相似比：<strong class="text-reference" data-bind="text: copyPercents().referenceCopyPercent + '%'"></strong></div>
                            <div class="col-md-1">/</div>
                            <div class="col-md-4">排除参考文献相似比：<strong class="text-others" data-bind="text: copyPercents().unReferenceCopyPercent + '%'"></strong></div>
                        </div>
                        <div class="row" style="height:24px;">
                            <div class="col-md-4 col-md-offset-2">可能引用本人已发表论文相似比：<strong class="text-published" data-bind="text: copyPercents().publishedCopyPercent + '%'"></strong></div>
                            <div class="col-md-1">/</div>
                            <div class="col-md-4">辅助排除本人已发表论文相似比：<strong class="text-others" data-bind="text: copyPercents().unPublishedCopyPercent + '%'"></strong></div>
                        </div>
                        <div class="row" style="height:24px;">
                            <div class="col-md-4 col-md-offset-2">可能引用本人学位论文相似比：<strong class="text-degree" data-bind="text: copyPercents().degreeCopyPercent + '%'"></strong></div>
                            <div class="col-md-1">/</div>
                            <div class="col-md-4">辅助排除本人学位论文相似比：<strong class="text-others" data-bind="text: copyPercents().unDegreeCopyPercent + '%'"></strong></div>
                        </div>
                        <div class="row" style="height:24px;">
                            <div class="col-md-8 col-md-offset-2">单篇论文最大相似比：<strong data-bind="text: MaxCopyPercentArticle().copyPercent + '%'"></strong>（<a data-bind="text: MaxCopyPercentArticle().title, attr: { href: MaxCopyPercentArticle().href }"></a>）</div>
                        </div>
                    </div>
                    <div class="row" style="margin-top:10px;">
                        <div class="col-md-12">
                            <table class="table table-bordered">
                                <tr>
                                    <td width="60%" style="padding:0;text-align:center;">
                                        <div style="line-height: 37px;font-weight:bold;">原文</div>
                                    </td>
                                    <td width="40%" style="padding:0;text-align:center;">
                                        <div style="line-height: 37px;font-weight:bold;">相似片段</div>
                                    </td>
                                </tr>
                                <tr style="font-size:12px;">
                                    <td style="padding:0;">
                                        <div style="padding:8px; height:600px;width:540px;overflow-y: auto;word-wrap:break-word;" id="fulltext">

                                        </div>
                                    </td>
                                    <td>
                                        <table class="table table-bordered" data-bind="with: SimilarFragment">
                                            <tr>
                                                <td width="100%">
                                                    <div class="row">
                                                        <div class="col-md-6">
                                                            片段相似比：<span style="color:red;">[<!-- ko text:(copyPercent * 100).toFixed('2') --><!-- /ko -->%]</span>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr data-bind="css: hasBanquan ? '' : 'text-nocopyright'">
                                                <td>[<!-- ko text:DBID --><!-- /ko -->]<!-- ko text:title --><!-- /ko --></td>
                                            </tr>
                                            <tr data-bind="css: hasBanquan ? '' : 'text-nocopyright'">
                                                <td>
                                                    <div class="row">
                                                        <div class="col-md-4" data-bind="text:creator"></div>
                                                        <div class="col-md-4" data-bind="text:date"></div>
                                                        <br />
                                                        <div class="col-md-4" data-bind="text:source"></div>
                                                    </div>
                                            </tr>
                                            <tr data-bind="css: hasBanquan ? '' : 'text-nocopyright'">
                                                <td>
                                                    <div style="height:440px; width:100%;overflow-y: auto;">
                                                        <div style="text-align: center;font-size: 15px;font-weight: bold;line-height: 30px;">
                                                            此片段相似字数（<!-- ko text:similarChars.length --><!-- /ko -->字）
                                                        </div>
                                                        <span data-bind="html: hasBanquan ? hitText : ''"></span>
                                                    </div>
                                                </td>
                                            </tr>
                                        </table>
                                        <!-- ko ifnot: SimilarFragment -->
                                        <div>
                                            <p>文档中颜色标注说明：</p>
                                            <p><div class="small-rect bg-others"></div><span class="text-others">红色</span>字体代表相似片段</p>
                                            <p><div class="small-rect bg-reference"></div><span class="text-reference">绿色</span>字体代表参考文献相似片段</p>
                                            <p><div class="small-rect bg-published"></div><span class="text-published">蓝色</span>字体代表可能引用本人已发表论文片段</p>
                                            <p style="color:#E15A00;"><img sty src="./Report(该文件夹请勿删除影响报告阅读)/click.png" style="padding:2px;" />请点击文档中有颜色标注的文本内容查看相似片段详情</p>
                                        </div>

                                        <!-- /ko -->
                                    </td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </div>

                <!--相似比为0-->
                <div id="part2zero" style="display:none">
                    <h2>检测结果</h2>
                    <div style="height:220px;">
                        <div style="width:400px;margin:40px auto 30px;">
                            <div style="float:left;">
                                <div id="graph1" data-bind="graphPie1: 0" style="width: 160px; height: 160px; margin: 20px; -webkit-tap-highlight-color: transparent; user-select: none; background: transparent;" _echarts_instance_="ec_1517366446953"><div style="position: relative; overflow: hidden; width: 160px; height: 160px;"><canvas width="160" height="160" data-zr-dom-id="zr_0" style="position: absolute; left: 0px; top: 0px; width: 160px; height: 160px; user-select: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></canvas></div></div>
                            </div>
                            <div style="float:left;">
                                <div id="graph2" class="container graph-originaltotal" style="width:200px;height:80px;margin:60px 0;">
                                    <div class="row" style="margin-bottom:20px;">
                                        <div class="col-md-6" style="text-align:right;padding-right:0;">检测字数</div>
                                        <div class="col-md-6">
                                            <span class="label label-main" data-bind="numeral: originalCharacterTotal"></span>
                                        </div>
                                    </div>
                                    <div class="row">
                                        <div class="col-md-6" style="text-align:right;padding-right:0;">原文总段落数</div>
                                        <div class="col-md-6">
                                            <span class="label label-main" data-bind="numeral: originalParagraphTotal"></span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 说明 -->
                <div id="part7" style="font-size:12px;" class="row">
                    <div class="col-md-8">


                        <p>说明：</p>
                        <p>1.送检文献总字数=送检文献的总字符数，包含汉字、非中文字符、标点符号、阿拉伯数字（不计入空格）</p>
                        <p>2.总相似比=送检论文与检测范围全部数据相似部分的字数/检测总字符数</p>
                        <p>3.参考文献相似比=送检论文与其参考文献相似部分的字数/检测总字符数</p>
                        <p>4.辅助排除参考文献相似比=总相似比-参考文献相似比</p>
                        <p>5.“单篇文献最大相似比”：送检文献与某一文献的相似比高于全部其他文献</p>
                        <p>6.“是否引用”：某一相似文献是否被送检文献列为其参考文献</p>

                    </div>
                    <!-- ko if: SimilarFragment -->
                    <div class="col-md-4">
                        <p>文档中颜色标注说明：</p>
                        <p><div class="small-rect bg-others"></div><span class="text-others">红色</span>字体代表相似片段</p>
                        <p><div class="small-rect bg-reference"></div><span class="text-reference">绿色</span>字体代表参考文献相似片段</p>
                        <p><div class="small-rect bg-published"></div><span class="text-published">蓝色</span>字体代表可能引用本人已发表论文片段</p>
                        <p><div class="small-rect bg-degree"></div><span class="text-degree">黄色</span>字体代表可能引用本人学位论文片段</p>
                    </div>
                    <!-- /ko -->
                </div>

            </div>

            <!-- 报告尾部 -->
            <div class="report-footer">
                <hr class="hr-footer">
                <div>
                    <p>检测报告由万方数据文献相似性检测系统算法生成</p>
                    <p>仅对您所选择的检测范围内检验结果负责，结果仅供参考</p>
                </div>
            </div>
        </div>
    </div>
    <script src="./Report(该文件夹请勿删除影响报告阅读)/underscore-min.js"></script>
    <script src="./Report(该文件夹请勿删除影响报告阅读)/jquery-1.12.4.min.js"></script>
    <script src="./Report(该文件夹请勿删除影响报告阅读)/iframeResizer.contentWindow.min.js"></script>
    <script src="./Report(该文件夹请勿删除影响报告阅读)/moment.min.js"></script>
    <script src="./Report(该文件夹请勿删除影响报告阅读)/knockout-3.4.0.js"></script>
    <script src="./Report(该文件夹请勿删除影响报告阅读)/bootstrap.min.js"></script>
    <script src="./Report(该文件夹请勿删除影响报告阅读)/echarts.min.js"></script>
    <script src="./Report(该文件夹请勿删除影响报告阅读)/numeral.min.js"></script>
    <script src="./Report(该文件夹请勿删除影响报告阅读)/require.js"></script>
    <script>
        require.config({
            paths: {
                'knockout': app.root + 'Scripts/knockout-3.4.0',
                'text': app.root + 'Scripts/text'
            }
        });

        // To keep the network tab clear when the visitor is running live examples,
        // preload the following.
        require(['text', 'knockout'], function () { });
    </script>

    <script src="./Report(该文件夹请勿删除影响报告阅读)/bindinghandlers.js"></script>
    <script src="./Report(该文件夹请勿删除影响报告阅读)/report.js"></script>

    <script src="./Report(该文件夹请勿删除影响报告阅读)/Detail.js"></script>
    <script>
        var data={"detailMatchTime":0,"hitDetailInfoList":[{"beginPosition":0,"copyPercent":0.00138965528,"hitBeginPosition":0,"hitLength":72,"hitText":"湖南大学\r\n学位论文原创性声明\r\n本人郑重声明：所呈交的论文是本人在导师的指导下独立进行研究所取得的研究成果。除了文中特别加以标注引用的内容外，","length":72,"originalChars":[0,1,2,3,6,7,8,9,10,11,12,13,14,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71],"recordIndex":14,"similarChars":[0,1,2,3,6,7,8,9,10,11,12,13,14,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71]},{"beginPosition":72,"copyPercent":0.000960497,"hitBeginPosition":1078,"hitLength":48,"hitText":"本论文不包含任何其他个人或集体已经发表或撰写过的作品成果。对本文的研究做出重要贡献的个人和集体，","length":47,"originalChars":[72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118],"recordIndex":17,"similarChars":[1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125]},{"beginPosition":119,"copyPercent":0.000817444234,"hitBeginPosition":755,"hitLength":48,"hitText":"均已在文中以明确方式标明。本人完全意识到本声明的法律结果由本人承担。\r\n学位论文作者签名：日期：","length":52,"originalChars":[119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,147,148,149,150,151,152,155,156,157,158,159,160,161,162],"recordIndex":15,"similarChars":[755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,783,784,785,786,787,788,795,796,797,798,799,800,801,802]},{"beginPosition":173,"copyPercent":0.000592647062,"hitBeginPosition":183,"hitLength":31,"hitText":"学位论文版权使用授权书\r\n本学位论文作者完全了解学校有关保留、","length":31,"originalChars":[173,174,175,176,177,178,179,180,181,182,183,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203],"recordIndex":14,"similarChars":[183,184,185,186,187,188,189,190,191,192,193,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213]},{"beginPosition":204,"copyPercent":0.00104224146,"hitBeginPosition":1425,"hitLength":51,"hitText":"使用学位论文的规定，同意学校保留并向国家有关部门或机构送交论文的复印件和电子版，允许论文被查阅和借阅。","length":51,"originalChars":[204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254],"recordIndex":17,"similarChars":[1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475]},{"beginPosition":255,"copyPercent":0.000735699839,"hitBeginPosition":918,"hitLength":36,"hitText":"本人授权湖南大学可以将本学位论文的全部或部分内容编入有关数据库进行检索，","length":36,"originalChars":[255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290],"recordIndex":12,"similarChars":[918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953]},{"beginPosition":291,"copyPercent":0.000572211,"hitBeginPosition":71320,"hitLength":28,"hitText":"可以采用影印、缩印或扫描等复制手段保存和汇编本学位论文。","length":28,"originalChars":[291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318],"recordIndex":11,"similarChars":[71320,71321,71322,71323,71324,71325,71326,71327,71328,71329,71330,71331,71332,71333,71334,71335,71336,71337,71338,71339,71340,71341,71342,71343,71344,71345,71346,71347]},{"beginPosition":321,"copyPercent":0.000817444234,"hitBeginPosition":984,"hitLength":44,"hitText":"本学位论文属于\r\n1、保密□，在年解密后适用本授权书。\r\n（请在以上相应方框内打“√”）","length":58,"originalChars":[321,322,323,324,325,326,327,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373],"recordIndex":12,"similarChars":[984,985,986,987,988,989,990,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027]},{"beginPosition":379,"copyPercent":0.000163488847,"hitBeginPosition":1144,"hitLength":14,"hitText":"导师签名：日期： 年 月 日","length":16,"originalChars":[379,380,381,390,391,392,393,394],"recordIndex":3,"similarChars":[1144,1145,1146,1147,1148,1149,1150,1151]},{"beginPosition":5237,"copyPercent":0.00036784992,"hitBeginPosition":100154,"hitLength":21,"hitText":"附录A 攻读学位期间所发表的学术论文等成果","length":26,"originalChars":[5237,5238,5239,5241,5242,5243,5244,5245,5246,5247,5248,5249,5250,5251,5252,5253,5258,5259],"recordIndex":3,"similarChars":[100154,100155,100156,100158,100159,100160,100161,100162,100163,100165,100166,100167,100168,100169,100170,100171,100173,100174]},{"beginPosition":5265,"copyPercent":0.0003065416,"hitBeginPosition":33317,"hitLength":16,"hitText":"附录2攻读学位期间参加的科研项目","length":20,"originalChars":[5265,5266,5269,5270,5271,5272,5273,5274,5275,5276,5277,5278,5279,5280,5281],"recordIndex":26,"similarChars":[33317,33318,33320,33321,33322,33323,33324,33325,33326,33327,33328,33329,33330,33331,33332]},{"beginPosition":8242,"copyPercent":0.0003065416,"hitBeginPosition":3464,"hitLength":17,"hitText":"调试到性能分析都要付出大量的劳动，","length":18,"originalChars":[8242,8243,8244,8245,8246,8247,8248,8249,8252,8253,8254,8255,8256,8257,8258],"recordIndex":8,"similarChars":[3464,3465,3466,3467,3468,3469,3470,3471,3473,3474,3475,3476,3477,3478,3479]},{"beginPosition":10286,"copyPercent":0.0009196248,"hitBeginPosition":109,"hitLength":45,"hitText":"面向一个高效的软件TLS模型HEUSPEC，研究了代码自动生成工具C2H的设计与实现方法。","length":47,"originalChars":[10288,10289,10290,10291,10292,10293,10294,10295,10296,10297,10298,10299,10300,10301,10302,10303,10304,10305,10306,10307,10308,10309,10310,10311,10312,10313,10314,10315,10316,10317,10318,10319,10320,10321,10322,10323,10324,10325,10326,10327,10328,10329,10330,10331,10332],"recordIndex":13,"similarChars":[109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153]},{"beginPosition":10333,"copyPercent":0.00194143015,"hitBeginPosition":248,"hitLength":112,"hitText":"该方法已在开源编译器Clang上实现。面向Rodinia，Ompser等基准程序的测试结果表明，C2H能够将带有简单标注语句的串行C代码转换为HEUSPEC并行代码，且其性能与手工编写的HEUSPEC并行代码的性能十分接近。","length":120,"originalChars":[10333,10334,10335,10336,10337,10338,10339,10340,10341,10342,10343,10344,10345,10346,10347,10348,10349,10350,10372,10373,10374,10375,10376,10377,10378,10379,10380,10381,10382,10383,10384,10385,10386,10387,10388,10389,10390,10391,10392,10393,10394,10395,10396,10397,10398,10399,10400,10401,10402,10403,10404,10405,10406,10407,10408,10409,10410,10411,10412,10413,10414,10415,10416,10417,10418,10419,10420,10421,10422,10423,10424,10425,10426,10427,10428,10429,10430,10431,10432,10433,10434,10435,10436,10437,10438,10439,10440,10441,10442,10443,10444,10445,10446,10447,10452],"recordIndex":13,"similarChars":[248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359]},{"beginPosition":12980,"copyPercent":0.000408722117,"hitBeginPosition":13159,"hitLength":25,"hitText":"介绍本文的主要工作内容并对本文组织结构做简要说明。","length":23,"originalChars":[12980,12981,12982,12983,12984,12985,12986,12987,12989,12990,12991,12992,12993,12994,12995,12997,12998,13000,13001,13002],"recordIndex":7,"similarChars":[13159,13160,13161,13162,13163,13164,13165,13166,13167,13168,13169,13171,13174,13175,13176,13177,13178,13179,13180,13183]},{"beginPosition":14159,"copyPercent":0.0002656694,"hitBeginPosition":22077,"hitLength":17,"hitText":"那么语句S1和语句S2不存在依赖，","length":26,"originalChars":[14162,14163,14164,14165,14166,14167,14168,14169,14170,14173,14174,14180,14181],"recordIndex":18,"similarChars":[22079,22080,22081,22082,22083,22084,22085,22086,22087,22089,22090,22091,22092]},{"beginPosition":14240,"copyPercent":0.00018392496,"hitBeginPosition":22077,"hitLength":17,"hitText":"那么语句S1和语句S2不存在依赖，","length":17,"originalChars":[14244,14245,14246,14247,14250,14251,14252,14253,14256],"recordIndex":18,"similarChars":[22079,22080,22081,22082,22084,22085,22086,22087,22093]},{"beginPosition":14315,"copyPercent":0.000388286018,"hitBeginPosition":22077,"hitLength":17,"hitText":"那么语句S1和语句S2不存在依赖，","length":55,"originalChars":[14315,14316,14317,14318,14319,14320,14321,14322,14323,14337,14357,14358,14359,14360,14363,14364,14365,14366,14369],"recordIndex":18,"similarChars":[22079,22080,22081,22082,22083,22084,22085,22086,22087,22093,22079,22080,22081,22082,22084,22085,22086,22087,22093]},{"beginPosition":14457,"copyPercent":0.0002656694,"hitBeginPosition":22077,"hitLength":17,"hitText":"那么语句S1和语句S2不存在依赖，","length":18,"originalChars":[14457,14458,14459,14460,14462,14463,14464,14465,14468,14469,14472,14473,14474],"recordIndex":18,"similarChars":[22079,22080,22081,22082,22084,22085,22086,22087,22089,22090,22091,22092,22093]},{"beginPosition":14549,"copyPercent":0.000347413821,"hitBeginPosition":14578,"hitLength":23,"hitText":" 控制流图模型 描述了一个程序所有的执行路径，","length":17,"originalChars":[14549,14550,14551,14552,14553,14554,14555,14556,14557,14558,14559,14560,14561,14562,14563,14564,14565],"recordIndex":25,"similarChars":[14579,14580,14581,14582,14586,14587,14588,14589,14590,14591,14592,14595,14596,14597,14598,14599,14600]},{"beginPosition":15000,"copyPercent":0.001532708,"hitBeginPosition":744,"hitLength":157,"hitText":"（4）语义分析：对结构上正确的源程序进行上下文有关性质的审查。\r\n（5）控制流分析：生成有向控制流图，用节点表示基本代码块，节点间的有向边代表控制流路径，反向边表示可能存在的循环；还可生成函数调用关系图，表示函数间的嵌套关系。\r\n（6）数据流分析：对控制流图进行遍历，记录变量的初始化点和引用点，保存相关数据信息。","length":140,"originalChars":[15000,15002,15003,15004,15005,15006,15008,15013,15014,15015,15016,15017,15018,15019,15020,15025,15032,15034,15035,15036,15037,15038,15039,15040,15041,15042,15043,15044,15046,15047,15048,15049,15063,15064,15065,15066,15067,15068,15069,15070,15071,15072,15073,15074,15075,15076,15093,15094,15095,15096,15097,15098,15099,15100,15101,15102,15104,15105,15106,15107,15108,15109,15110,15111,15112,15113,15130,15131,15132,15133,15134,15135,15136,15137,15139],"recordIndex":9,"similarChars":[744,746,747,748,749,750,752,756,757,758,759,760,761,762,763,771,777,779,780,781,782,783,784,786,787,788,789,790,791,792,793,794,796,797,808,809,810,811,812,813,814,815,816,817,818,819,836,837,838,839,840,841,842,843,844,845,838,839,842,843,846,847,850,851,852,853,883,884,885,886,887,888,889,890,891]},{"beginPosition":15339,"copyPercent":0.00024523327,"hitBeginPosition":54469,"hitLength":16,"hitText":"对该程序进行静态分析和动态分析。","length":16,"originalChars":[15339,15340,15345,15346,15347,15348,15349,15350,15351,15352,15353,15354],"recordIndex":21,"similarChars":[54469,54471,54472,54473,54474,54477,54478,54480,54481,54482,54483,54484]},{"beginPosition":16631,"copyPercent":0.000204361058,"hitBeginPosition":13903,"hitLength":20,"hitText":"它提供了一种现代的基于SSA的编译策略，","length":17,"originalChars":[16634,16635,16636,16637,16638,16639,16643,16644,16645,16646],"recordIndex":5,"similarChars":[13911,13912,13913,13914,13915,13916,13918,13919,13920,13921]},{"beginPosition":16673,"copyPercent":0.000797008164,"hitBeginPosition":11434,"hitLength":57,"hitText":"能够减少编译时间、链接时间、运行时间和空闲时间【l引。LLVM的项目是一个模块化和可重用的编译器和工具技术的集合。","length":70,"originalChars":[16675,16676,16677,16678,16686,16687,16688,16689,16690,16691,16692,16693,16694,16695,16696,16697,16698,16699,16700,16701,16703,16704,16705,16706,16707,16727,16728,16729,16730,16731,16732,16733,16734,16735,16738,16739,16740,16741,16742],"recordIndex":28,"similarChars":[11461,11462,11463,11464,11465,11469,11470,11471,11472,11473,11474,11475,11476,11477,11478,11479,11480,11481,11482,11483,11484,11485,11486,11488,11489,11440,11441,11442,11443,11444,11445,11446,11448,11449,11450,11451,11453,11454,11460]},{"beginPosition":16745,"copyPercent":0.000592647062,"hitBeginPosition":75,"hitLength":39,"hitText":"LLVM 核心库提供了与编译器相关的支持，可以作为多种语言编译器的后台来使用。","length":36,"originalChars":[16745,16746,16747,16748,16749,16750,16751,16753,16754,16755,16756,16757,16758,16759,16760,16761,16762,16763,16764,16765,16766,16767,16774,16775,16776,16777,16778,16779,16780],"recordIndex":4,"similarChars":[75,76,77,78,80,81,82,83,84,85,87,88,89,90,91,93,94,95,96,97,98,99,104,105,106,107,108,109,113]},{"beginPosition":18664,"copyPercent":0.00024523327,"hitBeginPosition":33061,"hitLength":18,"hitText":"因此算法的时间复杂度近似为O（n），","length":18,"originalChars":[18670,18671,18672,18673,18674,18675,18676,18677,18678,18679,18680,18681],"recordIndex":10,"similarChars":[33065,33066,33067,33068,33069,33070,33073,33074,33075,33076,33077,33078]},{"beginPosition":18824,"copyPercent":0.000510902668,"hitBeginPosition":3705,"hitLength":37,"hitText":"基于多面体模型的编译优化技术代表了程序自动并行化领域众多方向最先进的水平，","length":36,"originalChars":[18826,18827,18828,18829,18830,18831,18832,18833,18834,18835,18836,18837,18838,18839,18843,18844,18845,18846,18847,18848,18849,18852,18853,18854,18859],"recordIndex":6,"similarChars":[3705,3706,3707,3708,3709,3710,3711,3712,3713,3714,3715,3716,3717,3718,3722,3723,3724,3725,3726,3727,3728,3729,3730,3738,3741]},{"beginPosition":18891,"copyPercent":0.0002861055,"hitBeginPosition":3705,"hitLength":37,"hitText":"基于多面体模型的编译优化技术代表了程序自动并行化领域众多方向最先进的水平，","length":30,"originalChars":[18891,18892,18893,18894,18895,18896,18897,18898,18899,18900,18901,18902,18908,18920],"recordIndex":6,"similarChars":[3705,3706,3707,3708,3709,3710,3711,3712,3713,3714,3717,3718,3738,3741]},{"beginPosition":19011,"copyPercent":0.000224797172,"hitBeginPosition":4362,"hitLength":16,"hitText":"2）迭代空间是循环的迭代的集合，","length":17,"originalChars":[19012,19013,19014,19015,19016,19019,19020,19021,19024,19025,19027],"recordIndex":29,"similarChars":[4364,4365,4366,4367,4368,4369,4370,4371,4372,4373,4377]},{"beginPosition":19514,"copyPercent":0.000347413821,"hitBeginPosition":4612,"hitLength":22,"hitText":"· 首先，抽象分析构成多面体编译工具的前端，","length":20,"originalChars":[19514,19515,19516,19517,19518,19519,19520,19521,19522,19523,19525,19526,19527,19528,19531,19532,19533],"recordIndex":6,"similarChars":[4614,4615,4616,4617,4618,4619,4620,4621,4622,4626,4627,4628,4629,4630,4631,4632,4633]},{"beginPosition":19592,"copyPercent":0.000470030442,"hitBeginPosition":4690,"hitLength":34,"hitText":"然后，根据迭代空间和访存映射，通过调用线性整数规划过程计算依赖关系．","length":37,"originalChars":[19592,19593,19594,19596,19597,19598,19599,19600,19601,19602,19603,19604,19608,19609,19610,19611,19612,19619,19620,19624,19625,19626,19627],"recordIndex":6,"similarChars":[4690,4691,4692,4695,4696,4697,4698,4699,4700,4701,4702,4703,4704,4707,4708,4711,4712,4717,4718,4719,4720,4721,4722]},{"beginPosition":19679,"copyPercent":0.0013283469,"hitBeginPosition":4731,"hitLength":133,"hitText":"调度变换构成多面体编译工具的中间优化部分，其作用是在满足依赖关系的前提下，通过调用线性整数规划过程，计算一个充分利用目标程序语言和体系结构特点的调度，循环变换的结果也通过调度变换实现．\r\n· 最后，代码生成构成多面体编译工具的后端，该部分的任务可以再细分为两个阶段：","length":120,"originalChars":[19679,19680,19681,19682,19683,19684,19685,19686,19687,19688,19689,19691,19692,19693,19694,19697,19698,19699,19719,19720,19723,19724,19735,19736,19739,19740,19745,19746,19747,19750,19751,19752,19753,19754,19755,19756,19757,19758,19762,19763,19764,19765,19766,19767,19768,19769,19770,19773,19774,19775,19776,19779,19780,19781,19783,19784,19785,19786,19790,19791,19794,19795,19796,19797,19798],"recordIndex":6,"similarChars":[4731,4732,4733,4734,4735,4736,4740,4741,4742,4743,4744,4745,4746,4747,4748,4749,4750,4751,4781,4782,4783,4784,4785,4786,4787,4788,4789,4790,4795,4796,4797,4798,4799,4800,4801,4802,4803,4804,4827,4828,4829,4830,4831,4832,4833,4834,4835,4839,4840,4841,4842,4843,4844,4846,4847,4848,4849,4850,4853,4854,4859,4860,4861,4862,4863]},{"beginPosition":20740,"copyPercent":0.000204361058,"hitBeginPosition":28587,"hitLength":21,"hitText":"图神经网络（GNN）是基于深度学习的方法，","length":15,"originalChars":[20740,20741,20742,20743,20744,20745,20746,20747,20748,20749],"recordIndex":22,"similarChars":[28587,28588,28589,28590,28591,28592,28593,28594,28595,28596]},{"beginPosition":20842,"copyPercent":0.000592647062,"hitBeginPosition":28515,"hitLength":33,"hitText":"近年来，由于图的强大表现力，用机器学习分析图的研究越来越受到关注，","length":39,"originalChars":[20842,20843,20844,20845,20846,20847,20848,20849,20850,20851,20856,20857,20858,20859,20860,20861,20864,20865,20866,20867,20868,20869,20870,20871,20873,20874,20875,20878,20879],"recordIndex":22,"similarChars":[28515,28516,28517,28518,28519,28520,28521,28522,28523,28524,28528,28529,28530,28531,28532,28533,28534,28535,28536,28537,28538,28539,28540,28541,28542,28543,28544,28545,28546]},{"beginPosition":21276,"copyPercent":0.00179837737,"hitBeginPosition":993,"hitLength":188,"hitText":"但其复杂性给现有的机器学习算法带来了巨大的挑战。这是因为图的数据不规则。每个图都有一组数目可变的无序节点，图中的每个节点都有不同数量的相邻节点，导致一些重要的操作（例如卷积），在图像域中很容易计算，但不能直接应用于图域。此外，现有机器学习算法的一个核心假设是实例彼此独立。但是，对于图域数据来说，情况并非如此，图中每个实例（节点）通过一些复杂的连接信息与其他实例（邻居）相关，","length":177,"originalChars":[21279,21280,21281,21282,21284,21285,21286,21287,21288,21289,21290,21291,21294,21297,21298,21300,21301,21302,21303,21304,21305,21306,21307,21308,21309,21310,21326,21327,21328,21329,21330,21331,21332,21333,21334,21335,21336,21339,21342,21343,21344,21349,21350,21351,21352,21353,21354,21355,21356,21367,21368,21370,21371,21372,21373,21374,21375,21376,21377,21378,21379,21380,21381,21382,21383,21384,21385,21386,21387,21388,21394,21395,21396,21397,21398,21399,21400,21402,21429,21430,21431,21432,21433,21434,21435,21436,21437,21438],"recordIndex":2,"similarChars":[995,996,997,999,1000,1001,1002,1003,1004,1005,1006,1007,1010,1014,1015,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1059,1062,1063,1064,1081,1082,1083,1085,1087,1088,1089,1090,1093,1094,1095,1096,1097,1098,1099,1100,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1121,1122,1123,1124,1125,1126,1127,1128,1160,1161,1162,1163,1164,1165,1166,1167,1168,1180]},{"beginPosition":21486,"copyPercent":0.0005313388,"hitBeginPosition":22546,"hitLength":194,"hitText":"前者包括<mark data-type=technologies data-id=c39cf57b-df95-4c9e-9a8a-0d8ea330d625>图<mark data-type=technologies data-id=72b0bcc0-d8f9-4edd-919f-fa7c2560388c>神经网络</mark></mark>（Graph Neural Networks，","length":28,"originalChars":[21486,21487,21488,21489,21490,21491,21492,21493,21494,21495,21496,21498,21499,21500,21501,21502,21503,21505,21506,21507,21508,21509,21510,21511,21512,21513],"recordIndex":16,"similarChars":[22624,22699,22700,22701,22702,22717,22718,22719,22720,22721,22722,22724,22725,22726,22727,22728,22729,22731,22732,22733,22734,22735,22736,22737,22738,22739]},{"beginPosition":21593,"copyPercent":0.00112398586,"hitBeginPosition":374,"hitLength":64,"hitText":"它通过图节点之间的消息传递来捕获图的依赖性。与标准的神经网络不同，图神经网络保持一种状态，它可以以任意深度表示来自其邻域的信息。","length":70,"originalChars":[21593,21594,21595,21596,21597,21598,21599,21600,21601,21602,21603,21604,21605,21606,21607,21610,21616,21617,21618,21619,21620,21621,21622,21623,21624,21625,21626,21629,21630,21631,21632,21633,21634,21638,21639,21640,21641,21642,21643,21644,21645,21646,21647,21648,21649,21650,21651,21652,21655,21656,21657,21658,21660,21661,21662],"recordIndex":2,"similarChars":[374,375,376,377,378,379,380,381,382,383,384,385,386,387,390,391,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,414,415,416,417,418,420,421,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437]},{"beginPosition":22800,"copyPercent":0.0002861055,"hitBeginPosition":17542,"hitLength":17,"hitText":"图像中的像素点相应的视作图的节点，","length":21,"originalChars":[22803,22804,22805,22806,22809,22810,22811,22812,22813,22814,22815,22818,22819,22820],"recordIndex":23,"similarChars":[17542,17543,17544,17545,17546,17547,17548,17551,17552,17553,17554,17556,17557,17558]},{"beginPosition":22877,"copyPercent":0.0002656694,"hitBeginPosition":710,"hitLength":17,"hitText":"以图像分析为例，在欧几里得空间中，","length":16,"originalChars":[22877,22878,22879,22880,22881,22885,22886,22887,22888,22889,22890,22891,22892],"recordIndex":2,"similarChars":[710,711,712,715,717,718,719,720,721,722,723,724,725]},{"beginPosition":22946,"copyPercent":0.00018392496,"hitBeginPosition":710,"hitLength":17,"hitText":"以图像分析为例，在欧几里得空间中，","length":16,"originalChars":[22947,22952,22953,22954,22955,22956,22957,22960,22961],"recordIndex":2,"similarChars":[717,718,719,720,721,722,723,724,725]},{"beginPosition":24568,"copyPercent":0.00116485811,"hitBeginPosition":11817,"hitLength":92,"hitText":"是由美国航空航天局开发的一套代表流体动力学计算的应用程序集，它已经成为公认的用于测评大规模并行机和超级计算机的标准测试程序[71。NPB由9个程序组成，包括5个核心程序和3个模拟程序，","length":187,"originalChars":[24589,24605,24606,24624,24633,24634,24635,24636,24637,24638,24639,24640,24641,24644,24646,24651,24673,24674,24675,24676,24677,24678,24679,24680,24681,24682,24683,24684,24685,24686,24687,24688,24689,24690,24691,24692,24693,24694,24695,24698,24699,24700,24701,24702,24703,24704,24705,24735,24736,24737,24738,24739,24740,24746,24747,24748,24749],"recordIndex":1,"similarChars":[11817,11818,11819,11820,11821,11822,11823,11824,11825,11828,11829,11830,11838,11839,11840,11846,11848,11849,11850,11851,11852,11853,11854,11855,11856,11857,11858,11859,11860,11861,11862,11863,11864,11865,11866,11867,11868,11869,11870,11871,11872,11873,11874,11875,11876,11877,11881,11893,11894,11895,11896,11897,11898,11902,11903,11904,11905]},{"beginPosition":40777,"copyPercent":0.00106267759,"hitBeginPosition":128,"hitLength":41,"hitText":"国家重点研发计划项目“面向 E 级计算的能源勘探高性能应用软件系统与示范”（编号：","length":68,"originalChars":[40777,40778,40779,40780,40781,40782,40783,40784,40785,40786,40787,40788,40789,40790,40791,40792,40793,40794,40795,40796,40797,40798,40799,40800,40801,40802,40803,40804,40805,40806,40807,40808,40809,40815,40819,40820,40821,40822,40823,40824,40825,40826,40827,40828,40829,40830,40831,40832,40833,40834,40835,40841],"recordIndex":19,"similarChars":[128,129,130,131,132,133,134,135,138,139,140,142,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,168,138,139,140,142,144,145,146,147,148,149,150,151,155,156,157,158,164]},{"beginPosition":48399,"copyPercent":0.0003065416,"hitBeginPosition":9303,"hitLength":18,"hitText":"并为用户提供统一的、标准的编程接口，","length":16,"originalChars":[48399,48400,48401,48402,48403,48405,48406,48407,48408,48409,48410,48411,48412,48413,48414],"recordIndex":30,"similarChars":[9304,9305,9306,9307,9308,9309,9310,9311,9313,9314,9316,9317,9318,9319,9320]},{"beginPosition":59786,"copyPercent":0.00036784992,"hitBeginPosition":100154,"hitLength":21,"hitText":"附录A 攻读学位期间所发表的学术论文等成果","length":23,"originalChars":[59786,59787,59788,59790,59791,59792,59793,59794,59795,59796,59797,59798,59799,59800,59801,59802,59807,59808],"recordIndex":3,"similarChars":[100154,100155,100156,100158,100159,100160,100161,100162,100163,100165,100166,100167,100168,100169,100170,100171,100173,100174]},{"beginPosition":59873,"copyPercent":0.0003065416,"hitBeginPosition":33317,"hitLength":16,"hitText":"附录2攻读学位期间参加的科研项目","length":17,"originalChars":[59873,59874,59877,59878,59879,59880,59881,59882,59883,59884,59885,59886,59887,59888,59889],"recordIndex":26,"similarChars":[33317,33318,33320,33321,33322,33323,33324,33325,33326,33327,33328,33329,33330,33331,33332]},{"beginPosition":59892,"copyPercent":0.000470030442,"hitBeginPosition":128,"hitLength":41,"hitText":"国家重点研发计划项目“面向 E 级计算的能源勘探高性能应用软件系统与示范”（编号：","length":24,"originalChars":[59892,59893,59894,59895,59896,59897,59898,59899,59900,59901,59902,59903,59904,59905,59906,59907,59908,59909,59910,59911,59912,59913,59914],"recordIndex":19,"similarChars":[139,140,142,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163]},{"beginPosition":59956,"copyPercent":0.0003269777,"hitBeginPosition":47110,"hitLength":26,"hitText":"致谢\r\n致谢\r\n时光荏苒，当毕业论文真正接近尾声时，","length":20,"originalChars":[59956,59957,59960,59961,59962,59963,59964,59967,59968,59969,59970,59971,59972,59973,59974,59975],"recordIndex":24,"similarChars":[47110,47111,47118,47119,47120,47121,47122,47124,47125,47126,47127,47130,47131,47132,47133,47135]},{"beginPosition":60347,"copyPercent":0.00024523327,"hitBeginPosition":1549,"hitLength":18,"hitText":"为整个团队营造了良好的学术研究氛围。","length":17,"originalChars":[60348,60349,60353,60354,60355,60356,60357,60358,60359,60360,60361,60362],"recordIndex":20,"similarChars":[1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1564,1565]},{"beginPosition":60661,"copyPercent":0.000449594343,"hitBeginPosition":42761,"hitLength":27,"hitText":"感谢您在百忙之中能够抽出时间审阅本文并提出宝贵的意见，","length":25,"originalChars":[60661,60662,60665,60666,60667,60668,60669,60670,60671,60672,60673,60674,60675,60676,60677,60678,60679,60681,60682,60683,60684,60685],"recordIndex":27,"similarChars":[42761,42762,42765,42766,42767,42768,42771,42772,42773,42774,42775,42776,42777,42778,42779,42780,42781,42782,42783,42785,42786,42787]}],"publishCitedCopyPercent":0.0,"quickSearchTime":0,"recordHitInfoList":[{"copyPercent":0.00116485811,"recordIndex":1},{"copyPercent":0.00337195769,"recordIndex":2},{"copyPercent":0.0008991887,"recordIndex":3},{"copyPercent":0.000592647062,"recordIndex":4},{"copyPercent":0.000204361058,"recordIndex":5},{"copyPercent":0.00294279936,"recordIndex":6},{"copyPercent":0.000408722117,"recordIndex":7},{"copyPercent":0.0003065416,"recordIndex":8},{"copyPercent":0.001532708,"recordIndex":9},{"copyPercent":0.00024523327,"recordIndex":10},{"copyPercent":0.000572211,"recordIndex":11},{"copyPercent":0.00155314407,"recordIndex":12},{"copyPercent":0.00286105485,"recordIndex":13},{"copyPercent":0.0019823024,"recordIndex":14},{"copyPercent":0.000817444234,"recordIndex":15},{"copyPercent":0.0005313388,"recordIndex":16},{"copyPercent":0.00200273842,"recordIndex":17},{"copyPercent":0.00110354973,"recordIndex":18},{"copyPercent":0.001532708,"recordIndex":19},{"copyPercent":0.00024523327,"recordIndex":20},{"copyPercent":0.00024523327,"recordIndex":21},{"copyPercent":0.000797008164,"recordIndex":22},{"copyPercent":0.0002861055,"recordIndex":23},{"copyPercent":0.0003269777,"recordIndex":24},{"copyPercent":0.000347413821,"recordIndex":25},{"copyPercent":0.0006130832,"recordIndex":26},{"copyPercent":0.000449594343,"recordIndex":27},{"copyPercent":0.000797008164,"recordIndex":28},{"copyPercent":0.000224797172,"recordIndex":29},{"copyPercent":0.0003065416,"recordIndex":30}],"recordList":[{"articleId":"","conference":"","creator":["王世领"],"DBID":"4c3c0629-ba21-4587-8a17-71a022b30924","dataBaseInfoMap":[],"date":"2020-01-01T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":60713,"fulltextLength":48933,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":true,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":515,"schoolFirst":"","source":"","title":["无"],"volumn":"","uDocumentID":null},{"articleId":"4136603","conference":"","creator":["姜韶峰"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"0"},{"key":"授予学位单位","value":"中国科学院大学"},{"key":"出版时间","value":"2018-06-01 00:00:00.0"},{"key":"作者","value":"姜韶峰"},{"key":"CheckinID","value":"4136603"},{"key":"导师","value":"王剑"},{"key":"授予学位","value":"硕士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"基于PTS的龙芯处理器性能分析与优化"},{"key":"馆藏号","value":"Y3472602"},{"key":"专业","value":"计算机系统结构"},{"key":"DOI","value":null}],"date":"2018-06-01T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":45104,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"中国科学院大学","title":["基于PTS的龙芯处理器性能分析与优化"],"volumn":"","uDocumentID":null},{"articleId":"51714832","conference":"","creator":["王佳"],"DBID":"期刊","dataBaseInfoMap":[{"key":"CreatorSecond","value":null},{"key":"zz_xm","value":"王佳"},{"key":"CreatorFirst","value":"王佳"},{"key":"F_Volumn","value":null},{"key":"f_doi","value":"10.3969/j.issn.1007-1423.2019.23.013"},{"key":"有无版权","value":"1"},{"key":"qk_name","value":"现代计算机"},{"key":"CheckinID","value":"51714832"},{"key":"f_issue","value":"23"},{"key":"出版日期","value":"2019-08-15 00:00:00.0"},{"key":"f_year","value":"2019"},{"key":"收稿日期类型","value":"ReceivedDate"},{"key":"资源类型","value":"期刊"},{"key":"f_qcode","value":"xdjsj-xby201923013"},{"key":"zze_xm","value":"WANG Jia"},{"key":"qk_engname","value":"Modern Computer"},{"key":"收稿日期","value":"2019-06-16 00:00:00.0"},{"key":"F_Title","value":"图神经网络浅析"},{"key":"F_EngTitle","value":"Overview of Graph Neural Network"}],"date":"2019-06-16T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"收稿日期","fullLength":0,"fulltextLength":0,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"现代计算机","title":["图神经网络浅析"],"volumn":"","uDocumentID":null},{"articleId":"767167","conference":"","creator":["黎义斌"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"兰州理工大学"},{"key":"出版时间","value":"2015-06-05 00:00:00.0"},{"key":"作者","value":"黎义斌"},{"key":"CheckinID","value":"767167"},{"key":"导师","value":"李仁年"},{"key":"授予学位","value":"博士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"斜流泵叶顶间隙流动机理及其流固耦合动力学研究"},{"key":"馆藏号","value":"D710949"},{"key":"专业","value":"流体机械及工程"},{"key":"DOI","value":"10.7666/d.D710949"}],"date":"2015-06-05T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":0,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"兰州理工大学","title":["斜流泵叶顶间隙流动机理及其流固耦合动力学研究"],"volumn":"","uDocumentID":null},{"articleId":"17145986","conference":"","creator":[""],"DBID":"网文","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"zz_xm","value":""},{"key":"qk_name","value":"百度百科"},{"key":"CheckinID","value":"17145986"},{"key":"来源","value":"http://baike.baidu.com/view/2995210.html"},{"key":"收稿日期","value":"2008-04-20 00:00:00.0"},{"key":"F_Title","value":"LLVM"}],"date":"2008-04-20T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":1621,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"百度百科","title":["LLVM"],"volumn":"","uDocumentID":null},{"articleId":"4434738","conference":"","creator":["师文"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"0"},{"key":"授予学位单位","value":"中国科学院大学"},{"key":"出版时间","value":"2018-12-01 00:00:00.0"},{"key":"作者","value":"师文"},{"key":"CheckinID","value":"4434738"},{"key":"导师","value":"董建平;黄敏"},{"key":"授予学位","value":"硕士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"基于程序谱的软件错误定位系统的研究与实现"},{"key":"馆藏号","value":"Y3534584"},{"key":"专业","value":"计算机技术"},{"key":"DOI","value":null}],"date":"2018-12-01T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":32992,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"中国科学院大学","title":["基于程序谱的软件错误定位系统的研究与实现"],"volumn":"","uDocumentID":null},{"articleId":"34833773","conference":"","creator":["赵捷","李颖颖"],"DBID":"期刊","dataBaseInfoMap":[{"key":"CreatorSecond","value":"李颖颖"},{"key":"zz_xm","value":"赵捷%李颖颖%赵荣彩"},{"key":"CreatorFirst","value":"赵捷"},{"key":"F_Volumn","value":"29"},{"key":"f_doi","value":"10.13328/j.cnki.jos.005563"},{"key":"有无版权","value":"1"},{"key":"qk_name","value":"软件学报"},{"key":"CheckinID","value":"34833773"},{"key":"f_issue","value":"8"},{"key":"出版日期","value":"2018-08-06 00:00:00.0"},{"key":"f_year","value":"2018"},{"key":"收稿日期类型","value":null},{"key":"资源类型","value":"期刊"},{"key":"f_qcode","value":"rjxb201808014"},{"key":"zze_xm","value":"ZHAO Jie%LI Ying-Ying%ZHAO Rong-Cai"},{"key":"qk_engname","value":"Journal of Software"},{"key":"收稿日期","value":"2018-08-06 00:00:00.0"},{"key":"F_Title","value":"基于多面体模型的编译“黑魔法”"},{"key":"F_EngTitle","value":"\"Black Magic\" of Polyhedral Compilation"}],"date":"2018-08-06T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"收稿日期","fullLength":0,"fulltextLength":0,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":true,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"软件学报","title":["基于多面体模型的编译“黑魔法”"],"volumn":"","uDocumentID":null},{"articleId":"795473","conference":"","creator":["龚战毅"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"河南理工大学"},{"key":"出版时间","value":"2013-06-01 00:00:00.0"},{"key":"作者","value":"龚战毅"},{"key":"CheckinID","value":"795473"},{"key":"导师","value":"米爱中"},{"key":"授予学位","value":"硕士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"基于蚁群聚类的入侵检测方法研究"},{"key":"馆藏号","value":"D739257"},{"key":"专业","value":"计算机应用技术"},{"key":"DOI","value":null}],"date":"2013-06-01T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":43041,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"河南理工大学","title":["基于蚁群聚类的入侵检测方法研究"],"volumn":"","uDocumentID":null},{"articleId":"719949","conference":"","creator":["张朋"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"电子科技大学"},{"key":"出版时间","value":"2015-06-01 00:00:00.0"},{"key":"作者","value":"张朋"},{"key":"CheckinID","value":"719949"},{"key":"导师","value":"文军"},{"key":"授予学位","value":"硕士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"多核平台下串行程序的并行化改造"},{"key":"馆藏号","value":"D663723"},{"key":"专业","value":"计算机应用技术"},{"key":"DOI","value":null}],"date":"2015-06-01T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":0,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"电子科技大学","title":["多核平台下串行程序的并行化改造"],"volumn":"","uDocumentID":null},{"articleId":"16290847","conference":"","creator":[""],"DBID":"网文","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"zz_xm","value":""},{"key":"qk_name","value":"百度百科"},{"key":"CheckinID","value":"16290847"},{"key":"来源","value":"http://baike.baidu.com/view/1549698.html"},{"key":"收稿日期","value":"2008-04-20 00:00:00.0"},{"key":"F_Title","value":"程序静态分析"}],"date":"2008-04-20T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":0,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"百度百科","title":["程序静态分析"],"volumn":"","uDocumentID":null},{"articleId":"2853205","conference":"","creator":["张清辰"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"大连理工大学"},{"key":"出版时间","value":"2015-09-04 00:00:00.0"},{"key":"作者","value":"张清辰"},{"key":"CheckinID","value":"2853205"},{"key":"导师","value":"陈志奎"},{"key":"授予学位","value":"博士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"面向大数据特征学习的深度计算模型研究"},{"key":"馆藏号","value":"Y2969286"},{"key":"专业","value":"软件工程"},{"key":"DOI","value":null}],"date":"2015-09-04T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":0,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"大连理工大学","title":["面向大数据特征学习的深度计算模型研究"],"volumn":"","uDocumentID":null},{"articleId":"3539620","conference":"","creator":["周斌","西北工业大学"],"DBID":"会议","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"出版时间","value":"2016-07-11 00:00:00.0"},{"key":"作者","value":"周斌, 西北工业大学"},{"key":"CheckinID","value":"3539620"},{"key":"记录ID","value":"9515465"},{"key":"论文题名","value":"航空发动机转子支承系统动力学优化设计研究"},{"key":"资源类型","value":"会议"},{"key":"会议名称","value":"2016 Siemens PLM Software 仿真与试验技术大会"},{"key":"会议时间","value":"2016-07-11 00:00:00.0"},{"key":"zz_info","value":"^A周斌"},{"key":"zz_dwinfo","value":"^A西北工业大学"}],"date":"2016-07-11T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":0,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"2016 Siemens PLM Software 仿真与试验技术大会","title":["航空发动机转子支承系统动力学优化设计研究"],"volumn":"","uDocumentID":null},{"articleId":"727346","conference":"","creator":["李建"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"湖南大学"},{"key":"出版时间","value":"2015-05-26 00:00:00.0"},{"key":"作者","value":"李建"},{"key":"CheckinID","value":"727346"},{"key":"导师","value":"蔡皓"},{"key":"授予学位","value":"硕士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"低噪声椭圆摆线转子机油泵齿廓线型优化技术研究"},{"key":"馆藏号","value":"D671121"},{"key":"专业","value":"动力工程及工程热物理"},{"key":"DOI","value":null}],"date":"2015-05-26T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":47822,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"湖南大学","title":["低噪声椭圆摆线转子机油泵齿廓线型优化技术研究"],"volumn":"","uDocumentID":null},{"articleId":"2077269","conference":"","creator":["王家龙","刘艳红"],"DBID":"期刊","dataBaseInfoMap":[{"key":"CreatorSecond","value":"刘艳红"},{"key":"zz_xm","value":"王家龙%刘艳红%沈立"},{"key":"CreatorFirst","value":"王家龙"},{"key":"F_Volumn","value":"44"},{"key":"f_doi","value":"10.11896/j.issn.1002-137X.2017.11.018"},{"key":"有无版权","value":"1"},{"key":"qk_name","value":"计算机科学"},{"key":"CheckinID","value":"2077269"},{"key":"f_issue","value":"11"},{"key":"出版日期","value":"2017-11-15 00:00:00.0"},{"key":"f_year","value":"2017"},{"key":"收稿日期类型","value":"ReceivedDate"},{"key":"资源类型","value":"期刊"},{"key":"f_qcode","value":"jsjkx201711018"},{"key":"zze_xm","value":"WANG Jia-long%LIU Yan-hong%SHEN Li"},{"key":"qk_engname","value":"Computer Science"},{"key":"收稿日期","value":"2016-10-26 00:00:00.0"},{"key":"F_Title","value":"线程级猜测并行系统代码自动生成工具的设计与实现"},{"key":"F_EngTitle","value":"Design and Implementation of Automatic Code Generator for TLS System"}],"date":"2016-10-26T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"收稿日期","fullLength":0,"fulltextLength":0,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":true,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"计算机科学","title":["线程级猜测并行系统代码自动生成工具的设计与实现"],"volumn":"","uDocumentID":null},{"articleId":"4407892","conference":"","creator":["BOKANCHA OLHA"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"湖南大学"},{"key":"出版时间","value":"2017-04-01 00:00:00.0"},{"key":"作者","value":"BOKANCHA OLHA"},{"key":"CheckinID","value":"4407892"},{"key":"导师","value":"何莉萍"},{"key":"授予学位","value":"硕士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"一带一路中长沙国际企业孵化器的国际贸易项目管理"},{"key":"馆藏号","value":"D01346134"},{"key":"专业","value":"工业工程"},{"key":"DOI","value":null}],"date":"2017-04-01T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":150768,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"湖南大学","title":["一带一路中长沙国际企业孵化器的国际贸易项目管理"],"volumn":"","uDocumentID":null},{"articleId":"3539550","conference":"","creator":["李峰","吉林大学汽车工程学院"],"DBID":"会议","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"出版时间","value":"2016-07-11 00:00:00.0"},{"key":"作者","value":"李峰, 吉林大学汽车工程学院"},{"key":"CheckinID","value":"3539550"},{"key":"记录ID","value":"9515535"},{"key":"论文题名","value":"插电式混合动力汽车热管理系统开发及其控制算法研究"},{"key":"资源类型","value":"会议"},{"key":"会议名称","value":"2016 Siemens PLM Software 仿真与试验技术大会"},{"key":"会议时间","value":"2016-07-11 00:00:00.0"},{"key":"zz_info","value":"^A李峰"},{"key":"zz_dwinfo","value":"^A吉林大学汽车工程学院"}],"date":"2016-07-11T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":59866,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"2016 Siemens PLM Software 仿真与试验技术大会","title":["插电式混合动力汽车热管理系统开发及其控制算法研究"],"volumn":"","uDocumentID":null},{"articleId":"18294849","conference":"","creator":["机器之心"],"DBID":"网文","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"zz_xm","value":"机器之心"},{"key":"qk_name","value":"https://www.jiqizhixin.com"},{"key":"CheckinID","value":"18294849"},{"key":"来源","value":"https://www.jiqizhixin.com/articles/2019-01-07-8"},{"key":"收稿日期","value":"2019-01-07 14:44:00.0"},{"key":"F_Title","value":"图神经网络概述第三弹：来自IEEE Fellow的GNN综述"}],"date":"2019-01-07T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":0,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"https://www.jiqizhixin.com","title":["图神经网络概述第三弹：来自IEEE Fellow的GNN综述"],"volumn":"","uDocumentID":null},{"articleId":"17628987","conference":"","creator":["陈龙珠"],"DBID":"网文","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"zz_xm","value":"陈龙珠"},{"key":"qk_name","value":"http://www.sciencenet.cn/"},{"key":"CheckinID","value":"17628987"},{"key":"来源","value":"http://blog.sciencenet.cn/blog-39070-455300.html"},{"key":"收稿日期","value":"2011-06-14 22:24:00.0"},{"key":"F_Title","value":"研究生签署“学位论文原创性声明”必要吗？"}],"date":"2011-06-14T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":0,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"http://www.sciencenet.cn/","title":["研究生签署“学位论文原创性声明”必要吗？"],"volumn":"","uDocumentID":null},{"articleId":"2516992","conference":"","creator":["袁新宇"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"浙江大学"},{"key":"出版时间","value":"2013-01-12 00:00:00.0"},{"key":"作者","value":"袁新宇"},{"key":"CheckinID","value":"2516992"},{"key":"导师","value":"吴朝晖;李莹"},{"key":"授予学位","value":"博士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"面向共享存储系统结构并行编程若干关键问题的研究"},{"key":"馆藏号","value":"Y2512588"},{"key":"专业","value":"计算机科学与应用"},{"key":"DOI","value":null}],"date":"2013-01-12T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":0,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"浙江大学","title":["面向共享存储系统结构并行编程若干关键问题的研究"],"volumn":"","uDocumentID":null},{"articleId":"43991476","conference":"","creator":["徐兴荣","苏勤"],"DBID":"期刊","dataBaseInfoMap":[{"key":"CreatorSecond","value":"苏勤"},{"key":"zz_xm","value":"徐兴荣%苏勤%王劲松%寇龙江%文一华%王靖"},{"key":"CreatorFirst","value":"徐兴荣"},{"key":"F_Volumn","value":"31"},{"key":"f_doi","value":"10.12108/yxyqc.20190114"},{"key":"有无版权","value":"1"},{"key":"qk_name","value":"岩性油气藏"},{"key":"CheckinID","value":"43991476"},{"key":"f_issue","value":"1"},{"key":"出版日期","value":"2019-02-28 00:00:00.0"},{"key":"f_year","value":"2019"},{"key":"收稿日期类型","value":"ReceivedDate"},{"key":"资源类型","value":"期刊"},{"key":"f_qcode","value":"yxyqc201901014"},{"key":"zze_xm","value":"XU Xingrong%SU Qin%WANG Jinsong%KOU Longjiang%WEN Yihua%WANG Jing"},{"key":"qk_engname","value":"Lithologic Reservoirs"},{"key":"收稿日期","value":"2018-09-10 00:00:00.0"},{"key":"F_Title","value":"加权MPFI方法及其在三维连片处理中的应用"},{"key":"F_EngTitle","value":"Weighted MPFI method and its application in 3D joint processing"}],"date":"2018-09-10T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"收稿日期","fullLength":0,"fulltextLength":0,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"岩性油气藏","title":["加权MPFI方法及其在三维连片处理中的应用"],"volumn":"","uDocumentID":null},{"articleId":"8623260","conference":"","creator":[""],"DBID":"报纸","dataBaseInfoMap":[{"key":"bz_mc","value":"南昌日报"},{"key":"id_new","value":"8623260"},{"key":"banci","value":"06"},{"key":"xuhao","value":"4"},{"key":"batch","value":"5"},{"key":"banming","value":"质监天地"},{"key":"futi","value":""},{"key":"zuozhe","value":""},{"key":"zishu","value":"4009"},{"key":"riqi","value":"2013-06-27 00:00:00.0"},{"key":"biaoti","value":"大力提升检验能力   全力保障食品安全"},{"key":"id","value":"2131021"},{"key":"baoming","value":"南昌日报"}],"date":"2013-06-27T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":3889,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"","title":["大力提升检验能力   全力保障食品安全"],"volumn":"","uDocumentID":null},{"articleId":"3917147","conference":"","creator":["吴振东"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"国防科学技术大学"},{"key":"出版时间","value":"2015-09-01 00:00:00.0"},{"key":"作者","value":"吴振东"},{"key":"CheckinID","value":"3917147"},{"key":"导师","value":"卢凯"},{"key":"授予学位","value":"博士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"并行程序中bug检测技术研究"},{"key":"馆藏号","value":"D01232846"},{"key":"专业","value":"计算机科学与技术"},{"key":"DOI","value":null}],"date":"2015-09-01T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":0,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"国防科学技术大学","title":["并行程序中bug检测技术研究"],"volumn":"","uDocumentID":null},{"articleId":"4470674","conference":"","creator":["周光临"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"中国科学技术大学"},{"key":"出版时间","value":"2019-05-01 00:00:00.0"},{"key":"作者","value":"周光临"},{"key":"CheckinID","value":"4470674"},{"key":"导师","value":"陈锋"},{"key":"授予学位","value":"硕士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"组合知识图谱和深度学习的城市交通拥堵区域预测研究"},{"key":"馆藏号","value":"Y3564694"},{"key":"专业","value":"控制科学与工程"},{"key":"DOI","value":null}],"date":"2019-05-01T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":39148,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"中国科学技术大学","title":["组合知识图谱和深度学习的城市交通拥堵区域预测研究"],"volumn":"","uDocumentID":null},{"articleId":"415483","conference":"","creator":["杨柳"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"重庆大学"},{"key":"出版时间","value":"2013-04-01 00:00:00.0"},{"key":"作者","value":"杨柳"},{"key":"CheckinID","value":"415483"},{"key":"导师","value":"房斌"},{"key":"授予学位","value":"硕士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"临床CT图像中肝脏肿瘤分割研究"},{"key":"馆藏号","value":"D355770"},{"key":"专业","value":"计算机应用技术"},{"key":"DOI","value":"10.7666/d.D355770"}],"date":"2013-04-01T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":34836,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"重庆大学","title":["临床CT图像中肝脏肿瘤分割研究"],"volumn":"","uDocumentID":null},{"articleId":"891890","conference":"","creator":["林纲毅"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"上海师范大学"},{"key":"出版时间","value":"2015-12-01 00:00:00.0"},{"key":"作者","value":"林纲毅"},{"key":"CheckinID","value":"891890"},{"key":"导师","value":"张允熠"},{"key":"授予学位","value":"硕士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"马克思生态哲学思想探析及其现实价值"},{"key":"馆藏号","value":"D835689"},{"key":"专业","value":"马克思主义哲学"},{"key":"DOI","value":null}],"date":"2015-12-01T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":47835,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"上海师范大学","title":["马克思生态哲学思想探析及其现实价值"],"volumn":"","uDocumentID":null},{"articleId":"508418","conference":"","creator":["张翀斌"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"山东大学"},{"key":"出版时间","value":"2006-07-01 00:00:00.0"},{"key":"作者","value":"张翀斌"},{"key":"CheckinID","value":"508418"},{"key":"导师","value":"张晓敏"},{"key":"授予学位","value":"硕士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"基于模型检测技术的软件漏洞挖掘方法研究"},{"key":"馆藏号","value":"D449333"},{"key":"专业","value":"通信与信息系统"},{"key":"DOI","value":null}],"date":"2006-07-01T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":31513,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"山东大学","title":["基于模型检测技术的软件漏洞挖掘方法研究"],"volumn":"","uDocumentID":null},{"articleId":"4548060","conference":"","creator":["余燕"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"武汉科技大学"},{"key":"出版时间","value":"2019-05-11 00:00:00.0"},{"key":"作者","value":"余燕"},{"key":"CheckinID","value":"4548060"},{"key":"导师","value":"刘茂福"},{"key":"授予学位","value":"硕士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"基于视觉注意力与主题模型的图像中文描述生成方法研究"},{"key":"馆藏号","value":"Y3583784"},{"key":"专业","value":"计算机科学与技术"},{"key":"DOI","value":null}],"date":"2019-05-11T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":33399,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"武汉科技大学","title":["基于视觉注意力与主题模型的图像中文描述生成方法研究"],"volumn":"","uDocumentID":null},{"articleId":"4099545","conference":"","creator":["邓圣康"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"南昌航空大学"},{"key":"出版时间","value":"2018-06-01 00:00:00.0"},{"key":"作者","value":"邓圣康"},{"key":"CheckinID","value":"4099545"},{"key":"导师","value":"龚剑"},{"key":"授予学位","value":"硕士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"飞机客舱火灾的数值模拟研究"},{"key":"馆藏号","value":"D01443614"},{"key":"专业","value":"建筑与土木工程"},{"key":"DOI","value":null}],"date":"2018-06-01T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":45297,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"南昌航空大学","title":["飞机客舱火灾的数值模拟研究"],"volumn":"","uDocumentID":null},{"articleId":"2817384","conference":"","creator":["张璐"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"北京交通大学"},{"key":"出版时间","value":"2015-06-01 00:00:00.0"},{"key":"作者","value":"张璐"},{"key":"CheckinID","value":"2817384"},{"key":"导师","value":"张红延"},{"key":"授予学位","value":"硕士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"面向金融业务的计算逻辑描述语言及其编译器构建"},{"key":"馆藏号","value":"Y2917732"},{"key":"专业","value":"软件工程"},{"key":"DOI","value":null}],"date":"2015-06-01T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":45425,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"北京交通大学","title":["面向金融业务的计算逻辑描述语言及其编译器构建"],"volumn":"","uDocumentID":null},{"articleId":"2261562","conference":"","creator":["丁锐","数字工程与先进计算国家重点实验室 郑州 450002; 赵荣彩"],"DBID":"会议","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"出版时间","value":"2013-07-26 00:00:00.0"},{"key":"作者","value":"丁锐, 数字工程与先进计算国家重点实验室 郑州 450002; 赵荣彩, 数字工程与先进计算国家重点实验室 郑州 450002; 徐金龙, 数字工程与先进计算国家重点实验室 郑州 450002; 傅立国, 数字工程与先进计算国家重点实验室 郑州 450002"},{"key":"CheckinID","value":"2261562"},{"key":"记录ID","value":"8266817"},{"key":"论文题名","value":"自动并行化中不规则循环的代码生成"},{"key":"资源类型","value":"会议"},{"key":"会议名称","value":"第四届全国智能信息处理学术会议"},{"key":"会议时间","value":"2013-07-26 00:00:00.0"},{"key":"zz_info","value":"^A丁锐^B1%^A赵荣彩^B2%^A徐金龙^B3%^A傅立国^B4"},{"key":"zz_dwinfo","value":"^A数字工程与先进计算国家重点实验室 郑州 450002"}],"date":"2013-07-26T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":19070,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"第四届全国智能信息处理学术会议","title":["自动并行化中不规则循环的代码生成"],"volumn":"","uDocumentID":null},{"articleId":"3910599","conference":"","creator":["许名广"],"DBID":"学位","dataBaseInfoMap":[{"key":"有无版权","value":"1"},{"key":"授予学位单位","value":"国防科学技术大学"},{"key":"出版时间","value":"2016-03-01 00:00:00.0"},{"key":"作者","value":"许名广"},{"key":"CheckinID","value":"3910599"},{"key":"导师","value":"刘亚萍"},{"key":"授予学位","value":"硕士"},{"key":"资源类型","value":"学位"},{"key":"正题名","value":"基于SDN的位置/标识分离网络控制技术研究与实现"},{"key":"馆藏号","value":"D01232348"},{"key":"专业","value":"计算机科学与技术"},{"key":"DOI","value":null}],"date":"2016-03-01T00:00:00","dateSpecified":true,"degree":"","detectDate":"9999-01-01T00:00:00","detectDateSpecified":true,"detectDateType":"","fullLength":0,"fulltextLength":46099,"htmlPath":"","isDisplayFulltext":true,"isPublishedSelfCited":false,"isReference":false,"isSelfCited":false,"isUnPublishedSelfCited":false,"issue":"","paragraphNum":0,"schoolFirst":"","source":"国防科学技术大学","title":["基于SDN的位置/标识分离网络控制技术研究与实现"],"volumn":"","uDocumentID":null}],"referenceCitedCopyPercent":0.005803854,"selfCitedCopyPercent":0.0,"totalCopyPercent":0.0292645041,"unPublishCitedCopyPercent":0.0};
        var isPublished = true;
        var totalCopyPercent = (data.totalCopyPercent * 100).toFixed(2);
        var referenceCopyPercent = (data.referenceCitedCopyPercent * 100).toFixed(2);
        var degreeCopyPercent = (data.unPublishCitedCopyPercent * 100).toFixed(2);
        var publishedCopyPercent = (data.publishCitedCopyPercent * 100).toFixed(2);
        var unReferenceCopyPercent = ((data.totalCopyPercent - data.referenceCitedCopyPercent) * 100).toFixed(2);
        var unDegreeCopyPercent = ((data.totalCopyPercent - data.unPublishCitedCopyPercent) * 100).toFixed(2);
        var unPublishedCopyPercent = ((data.totalCopyPercent - data.publishCitedCopyPercent) * 100).toFixed(2);

        viewModel.copyPercentGraph(totalCopyPercent);
        viewModel.copyPercents({
            totalCopyPercent: totalCopyPercent,
            referenceCopyPercent: referenceCopyPercent,
            degreeCopyPercent: degreeCopyPercent,
            publishedCopyPercent: publishedCopyPercent,
            unReferenceCopyPercent: unReferenceCopyPercent,
            unDegreeCopyPercent: unDegreeCopyPercent,
            unPublishedCopyPercent: unPublishedCopyPercent
        });

        viewModel.originalCharacterTotal(data.recordList[0].fulltextLength);
        viewModel.originalParagraphTotal(data.recordList[0].paragraphNum);

        //
        for (var i = 0; i < data.recordHitInfoList.length; i++) {
            var recordHitInfo = data.recordHitInfoList[i];

            var recordIndex = recordHitInfo["recordIndex"];
            var copyPercent = recordHitInfo["copyPercent"];

            data.recordList[recordIndex].copyPercent = copyPercent;
        }


        // 全文长度
        var textLength = data.recordList[0].fullLength;


        // 相似文献列表
        var similarArticles = _.drop(data.recordList, 1);

        if (totalCopyPercent != 0) {
            // 最大
            var maxCopyPercentArticle = _.max(similarArticles, 'copyPercent');
            viewModel.MaxCopyPercentArticle({
                copyPercent: (maxCopyPercentArticle.copyPercent * 100).toFixed('2'),
                title: maxCopyPercentArticle.title[0],
                href: '#'
            });
        }
        else {

            $("#part2").hide();
            $("#part2zero").show();
        }
        // 相似片段
        var similarFragments = data.hitDetailInfoList;

        //similarFragments = _.filter(similarFragments, function(item){ return item.copyPercent >= 0.001;  }); // 0.1%

        _.forEach(similarFragments, function (hitDetailInfo, i) {
            var record = data.recordList[hitDetailInfo.recordIndex];
            if (record.DBID.indexOf('专利') != -1) {
                record.source = "中文专利全文数据库";
                var pname, number;
                _.find(record.dataBaseInfoMap, function (i) {
                    if (i.key == "pname")
                        pname = i.value;
                    if (i.key == "number")
                        number = i.value;
                })
                record.title[0] = pname + number;
            }
            if (record.DBID.indexOf('报纸') != -1) {
                if (record.dataBaseInfoMap != null && record.dataBaseInfoMap.length != 0) {
                    record.source = _.find(record.dataBaseInfoMap, function (record) { return record.key == 'baoming' }).value;
                    record.title[0] = _.find(record.dataBaseInfoMap, function (record) { return record.key == 'biaoti' }).value;
                    if (record.creator[0] == "无" || record.creator[0] == "") {
                        record.creator[0] = "-";
                    }
                    else {
                        record.creator[0] = _.find(record.dataBaseInfoMap, function (record) { return record.key == 'zuozhe' }).value;
                    }
                }
                else {
                    record.source = "-";
                    record.title[0] = "-";
                    record.creator[0] = "-";
                    record.date = "-";
                }
            }
            hitDetailInfo.title = record.title[0];
            hitDetailInfo.creator = record.creator[0];
            hitDetailInfo.DBID = record.DBID + '论文';
            if (hitDetailInfo.DBID == "网文论文") {
                var wwurl, qkname;
                _.find(record.dataBaseInfoMap, function (i) {
                    if (i.key == "qk_name")
                        wwurl = i.value;
                    if (i.key == "来源")
                        qkname = i.value;
                })
                hitDetailInfo.source = wwurl + '：' + qkname;
            }
            else if (record.DBID.indexOf('报纸') != -1) {
                if (record.dataBaseInfoMap != null && record.dataBaseInfoMap.length != 0) {
                    hitDetailInfo.source = _.find(record.dataBaseInfoMap, function (record) { return record.key == 'baoming' }).value;
                }
                else {
                    hitDetailInfo.source = "-";
                }
            }
            else {
                hitDetailInfo.source = record.source ? record.source : '-';
            }
            hitDetailInfo.date = moment(record.date).format('YYYY-MM-DD');
            if (record.DBID.indexOf('报纸') != -1) {
                if (record.dataBaseInfoMap != null && record.dataBaseInfoMap.length != 0) {
                    hitDetailInfo.date = moment(_.find(record.dataBaseInfoMap, function (record) { return record.key == 'riqi' }).value).format('YYYY-MM-DD');
                }
                else {
                    hitDetailInfo.date = "-";
                }
            }
            hitDetailInfo.isReference = record.isReference ? '是' : '否';

            hitDetailInfo.left = hitDetailInfo.beginPosition / textLength * 400 + 1 + 'px';
            hitDetailInfo.width = hitDetailInfo.length / textLength * 400 + 'px';

            hitDetailInfo.index = i;
        });


        //
        var prefix = '<span>';
        var suffix = '</span>';

        // 全文，注意：similarFragments被反转
        var htmlContent="湖南大学\r\n学位论文原创性声明\r\n本人郑重声明：所呈交的论文是本人在导师的指导下独立进行研究所取得的研究成果。除了文中特别加以标注引用的内容外，本论文不包含任何其他个人或集体已经发表或撰写的成果作品。对本文的研究做出重要贡献的个人和集体，均已在文中以明确方式标明。本人完全意识到本声明的法律后果由本人承担。\r\n作者签名：日期：     年月日\r\n学位论文版权使用授权书\r\n本学位论文作者完全了解学校有关保留、使用学位论文的规定，同意学校保留并向国家有关部门或机构送交论文的复印件和电子版，允许论文被查阅和借阅。本人授权湖南大学可以将本学位论文的全部或部分内容编入有关数据库进行检索，可以采用影印、缩印或扫描等复制手段保存和汇编本学位论文。\r\n本学位论文属于\r\n1、保密□，在年解密后适用本授权书。\r\n2、不保密□。\r\n（请在以上相应方框内打“√”）作者签名：日期：     年月日导师签名：日期：     年月日\r\n摘要\r\n随着高性能计算技术的快速发展，并行编程技术在实际工程应用中占据着越来越重要的地位。尤其是在科学计算相关领域，并行化技术成为了解决程序结构复杂、计算量大、数据密集以及执行周期长等问题的关键途径。然而，现有的程序并行性分析工具在处理具备上述特征的程序时仍存在着较大的局限性，且目前的多种并行编程手段在使用时缺少统一的标准编程接口。因此，串行程序的并行化在程序的并行性识别和并行程序开发两个阶段均存在着较大的难度，研究一种在上述两个阶段均具备良好表现的串行程序并行化方法是十分必要的。\r\n本文借助深度学习技术来研究串行程序的并行化方法，提出了包含数据集、识别方法、标记语言和辅助平台的一整套解决方案，主要工作如下：\r\n（1）设计并构造了一个通用图数据集GFCPD（Graphs For Code Parallelism Discovery，程序并行性识别图数据集）。本文使用程序的上下文流图（Contextual Flow Graph，XFG）作为代码语义的表示形式，构造了一个可以用于串行程序并行性识别任务的通用图数据集GFCPD，同时设计并实现了一套生成GFCPD数据的自动化脚本。\r\n（2）提出了一种串行程序并行性识别的深度学习模型。本文将串行程序的并行性识别视为二元分类问题，建立了一个基于深度图卷积神经网络（Deep Graph Convolutional Neural Network，DGCNN）的深度学习模型，并通过该模型在GFCPD数据集上的表现验证了深度学习方法在串行程序的并行性识别问题上具备可行性与有效性。\r\n（3）设计并实现了一种并行标记语言PML。本文使用XML技术实现了并行标记语言PML，为不同的并行编程模型提供了格式统一的PML标签用于结合C/C++语言进行并行程序开发，为多种并行编程手段的混合使用提供了统一的标准编程接口和更加简易便捷的途径。\r\n（4）搭建了一个并行编程辅助平台。为了对上述工作成果进行集成和转化，本文搭建了一个并行编程辅助平台，从串行程序的并行性识别、并行程序开发、并行程序调试三个方面提供了完整的串行程序并行化流程，有效地降低了并行化技术的使用门槛。\r\n关键词：并行编程；并行性识别；并行标记语言；深度学习；图卷积神经网络\r\nAbstract\r\nWith the rapid development of high-performance computing technology, parallel programming technology plays an increasingly important role in practical engineering applications. Especially in the field of scientific computing, parallelization technology has become a key way to solve the problems of complex program structure, large amount of calculation, data intensive and long execution cycle. However, the existing program parallelism analysis tools still have greater limitations when processing programs with the above characteristics, and the current multiple parallel programming methods lack a unified standard programming interface when used. Therefore, the parallelization of sequential programs has great difficulty in both the parallelism discovery and parallel program development. It is necessary to do a research on parallelization method of sequential programs which has good performance in the above two stages.\r\nThe purpose of this paper is to explore the parallelization method of sequential programs with the help of deep learning technology, and proposes a set of solutions including data sets, recognition methods, markup languages and auxiliary platforms. The main work is as follows:\r\n(1) Design and construct a general graph data set GFCPD (Graphs For Code Parallelism Discovery). In this paper, the program's Contextual Flow Graph (XFG) is used as the semantic representation of the code. A general graph data set GFCPD that can be used for discovering parallelism in sequential programs is constructed, and a set of automated scripts for generating GFCPD data was designed and implemented.\r\n(2) A deep learning model for sequential program parallelism discovery is proposed. In this paper, the parallelism discovery of sequential programs is regarded as a binary classification problem. A deep learning model based on Deep Graph Convolutional Neural Network (DGCNN) is built, and the model is used on the GFCPD dataset. The performance verifies that the deep learning method has the feasibility and effectiveness in the sequential program parallelism discovery problem.\r\n(3) Design and implement a parallel markup language PML. This paper uses XML technology to implement the parallel markup language PML which provides unified formatted PML tags for different parallel programming models. Providing a unified standard programming interface and a simpler and more convenient way for the mixed use of a variety of parallel programming methods.\r\n(4) A parallel programming auxiliary platform is built. In order to integrate and transform the above work results, this paper builds a parallel programming auxiliary platform, which provides a complete sequential program parallelization process from the three aspects of serial program parallelism discovery, parallel program development, and parallel program debugging. It has lowered the threshold of parallelization technology.\r\nKey Words: parallel programming; parallelism discovering; markup language for parallel programming; deep learning; graph convolutional neural network\r\n目录\r\n学位论文原创性声明和学位论文版权使用授权书 I\r\n摘要 II\r\nAbstract III\r\n插图索引 VII\r\n附表索引 IX\r\n第1章绪论 1\r\n1.1研究背景和意义 1\r\n1.2国内外研究现状 3\r\n1.2.1国内研究现状 3\r\n1.2.2国外研究现状 4\r\n1.3本文的主要工作 5\r\n1.4本文的组织结构 6\r\n第2章相关理论与方法 7\r\n2.1程序的并行性分析 7\r\n2.1.1数据依赖与控制依赖 7\r\n2.1.2静态分析与动态分析方法 8\r\n2.1.3并行性分析工具 9\r\n2.2 LLVM编译器框架与IR 10\r\n2.3程序的上下文流图(XFG) 12\r\n2.4 Polyhedral模型和Pluto编译器 13\r\n2.5图神经网络与图卷积神经网络 15\r\n2.5.1图的定义 15\r\n2.5.2GNN简介 16\r\n2.5.3GCN简介 17\r\n2.6本章小结 18\r\n第3章 GFCPD的构造 19\r\n3.1数据搜集 19\r\n3.2数据提取 21\r\n3.2.1循环提取 22\r\n3.2.2代码重构 24\r\n3.2.3编译检验 25\r\n3.3数据标注 26\r\n3.4XFG的生成 28\r\n3.5数据集规模 32\r\n3.6本章小结 33\r\n第4章基于DGCNN的串行程序并行性识别方法 34\r\n4.1数据预处理 34\r\n4.2 基于DGCNN的串行程序并行性识别模型 36\r\n4.2.1 DGCNN的构建 36\r\n4.2.2损失函数的确定 38\r\n4.3实验结果与分析 40\r\n4.4本章小结 42\r\n第5章 PML与并行编程平台 44\r\n5.1基于XML的并行标记语言 45\r\n5.1.1可行性分析 45\r\n5.1.2 PML的设计与实现 46\r\n5.2并行编程辅助平台 50\r\n5.2.1基础功能的实现 51\r\n5.2.2串行代码的并行性识别功能的集成 55\r\n5.3本章小结 58\r\n结论 59\r\n参考文献 61\r\n附录A 攻读学位期间发表的学术论文与获得的成果 66\r\n附录B 攻读学位期间参加的科研项目 67\r\n致谢 68\r\n插图索引\r\n图2.1 数据依赖关系示例图 8\r\n图2.2 控制依赖关系示例图 8\r\n图2.3 传统静态编译器架构示意图 11\r\n图2.4 LLVM架构示意图 11\r\n图2.5 LLVM IR示例图 11\r\n图2.6 XFG示例图 12\r\n图2.7 Polyhedral模型示例图 13\r\n图2.8 基于多面体模型的编译工具工作流程示意图 14\r\n图2.9 有向图及其邻接矩阵示例图 16\r\n图2.10 GNN状态更新示例图 17\r\n图2.11 GNN状态更新与输出流程示例图 17\r\n图2.12 卷积核示例图 18\r\n图3.1 第3章工作目录结构说明图 19\r\n图3.2 程序的抽象结构示意图 22\r\n图3.3 循环提取算法流程图 23\r\n图3.4 提取结果示例图 23\r\n图3.5 代码重构算法流程图 24\r\n图3.6 重构结果示例图 25\r\n图3.7 编译命令 26\r\n图3.8 Pluto转换命令 27\r\n图3.9 Pluto转换结果示例图 27\r\n图3.10 LLVM IR语句基本结构示例图 28\r\n图3.11 非IR指令内容示例图 28\r\n图3.12 构造XFG的算法流程图 29\r\n图3.13 基于标识符的XFG存储结构示例图 30\r\n图3.14 步骤(4)前后对比效果图 30\r\n图3.15 步骤(5)前后对比效果图 30\r\n图3.16 基于LLVM IR语句的Dual-XFG存储结构示例图 31\r\n图3.17 GFCPD数据格式示意图 31\r\n图4.1 DGCNN输入数据格式示意图 34\r\n图4.2 数据预处理总体流程图 37\r\n图4.3 DGCNN的总体结构示意图 37\r\n图4.4 One-hot编码示例图 38\r\n图4.5 损失函数对比实验效果图 39\r\n图4.6 NCC-Model模型结构示意图[34] 42\r\n图5.1 并行标记语言技术路线图 47\r\n图5.2 C语言与PML程序示例图 48\r\n图5.3 XSLT示例图 49\r\n图5.4 PML向C/C++语言转换示例图 49\r\n图5.5 PML转换算法描述图 50\r\n图5.6 并行编程辅助平台架构图 51\r\n图5.7 平台视图层效果图 53\r\n图5.8 标签详情页面效果图 53\r\n图5.9 GateOne配置示例图 54\r\n图5.10 代码转换效果图 54\r\n图5.11 SSH终端远程调试效果图 55\r\n图5.12 串行代码的并行性识别功能集成流程图 56\r\n图5.13 数据提取阶段提取结果示例图 57\r\n图5.14 串行程序并行性识别结果示例图 57\r\n附表索引\r\n表2.1 现有并行性分析工具信息表 9\r\n表3.1 Livermore循环详情表 20\r\n表3.2 NPB详情表 20\r\n表3.3 一般程序详情表 21\r\n表3.4 Pluto命令参数表 27\r\n表3.5 DGCNN使用的数据集信息表 32\r\n表3.6 GFCPD数据集信息表 32\r\n表4.1 节点类型标签信息表 35\r\n表4.2 图嵌入训练所使用的数据集信息表 36\r\n表4.3 图嵌入结果详细信息 36\r\n表4.4 损失函数对比试验参数及测试结果表 40\r\n表4.5 对比实验中DGCNN模型参数表 40\r\n表4.6 对比实验一实验结果表 41\r\n表4.7 对比试验二实验结果表 41\r\n表4.8 对比实验三实验结果表 42\r\n表5.1 能源勘探行业软件对比信息表 44\r\n表5.2 基于XML的标记语言相关研究信息表 46\r\n表5.3 数据库标签表结构 51\r\n表5.4 数据库标签类别表结构 52\r\n表5.5 数据库并行编程模型表结构 52\r\n表5.6 控制层相关实现技术信息表 54\r\n第1章绪论\r\n1.1研究背景和意义\r\n近十年以来，半导体的发展趋势表明，过去几十年来时钟速度的惊人提高已经结束，单核处理器对计算机应用性能提升和成本降低的贡献达到了极限[1]，但各个领域的发展仍然需要计算机性能的进一步提升。这推动了硬件和架构的设计理念向集成多处理器设计的转变[2]。近年来，多核系统越来越受欢迎，并行化已经成为了新的趋势，高性能计算领域也正在蓬勃发展。然而，由于串行的编程思想仍然深深地根植于当前的应用程序开发流程中，尽管大多数硬件设备（如多核处理器、GPU等）均具备为并行计算而设计的设想，但目前大部分流行的应用程序仍然是串行的，未能充分利用多核技术带来的潜在性能提升[3]。换言之，在大多数情况下，现代体系结构提供的很大一部分计算资源并没有被充分利用。\r\n针对这一现状，并行程序开发的新方法和新技术正在逐步发展起来。例如，众多程序并行性分析工具的提出以及OpenMP、Click、MPI以及CUDA等标准不一、接口各异的并行编程模型和框架的出现，使得并行程序开发的方法更加便捷和多样化[4]。从某种意义上来说，在生产科学和工业领域广泛遇到的数据密集型应用，只需通过对其代码中的并行性进行全面分析，将其中可以并行化的部分利用上述手段进行并行化改造，即可达到大幅提高应用性能和计算资源利用率的目的[5]。但需要说明的是，一种工具或手段并不能很好的完成这一目标，目前的并行程序开发过程中，往往需要在不同阶段结合应用不同的并行编程技术，以使得程序发挥更好的性能，计算资源得到更好的利用。\r\n这些阶段主要包括：（1）在编码阶段，采用人工的方式根据实际硬件平台的特点和算法的并行性，使用上述并行编程框架在编码过程中对算法中可以并行化的步骤直接采取并行化开发，以达到使代码并行执行的目的。在这一阶段可以很好的将硬件平台优势、开发人员根据其行业经验进行的主观判断以及算法的特征结合在一起，但对于大型的应用程序，本阶段的并行程序开发任务会变得十分繁琐和复杂；（2）在编译阶段，通过编译器优化功能将程序自动并行化，这一手段的重心主要集中在程序中的循环片段上，编译器自动地识别出循环片段并通过静态分析技术分析其中的依赖关系，进而判断该循环片段能否进行并行优化，然后对可以并行化的循环片段自动生成并行化的机器代码。这一过程使开发人员摆脱了手动并行化的繁琐过程，更加准确、快速地发现了串行程序的并行潜力，但优化以后的程序不具备可读性且性能会因编译器的选择、硬件平台的架构和程序本身的特征而各有不同；（3）在代码重构阶段，使用程序并行性分析工具通过程序的静态分析或动态分析技术，自动识别串行程序中可以并行的片段而不进行优化，仅对开发人员进行指导建议，结合人工的方式半自动的将串行代码转换为并行代码。显然在阶段（3）对程序进行并行化改造结合了（1）、（2）两个阶段的优势，且在较大程度上避免了其短板，然而该阶段在实际操作中仍具备着很大的困难。如有的程序并行性分析工具使用的分析算法对程序的部分特征，尤其是循环体中被迭代语句的数学表示存在限制；还有的则需要在程序的执行过程中对程序的动态特征进行收集和分析。这些限制对于程序复杂、计算量大、数据密集并且执行时间长的应用程序并不友好。\r\n由此可见，虽然高性能计算技术正在逐渐发展、成熟和完善，但熟练地进行并行程序的开发仍然不是一项简单的任务。首先，它对于开发工具和硬件平台存在着很大的依赖，从编程、调试到性能分析都需要付出大量的劳动。其次，它对开发人员的要求较高，需要具备丰富的计算机知识、对并行编程理论技术的深入理解和对计算机程序特征的准确把握等。但这并没有阻挡高性能计算技术因其经济且高效的特点成为解决计算量大、数据密集型问题的主要途径，诸如医疗成像、气候模拟、药物发现、地质能源勘探等生产和科研相关领域的从业人员为了提高工作效率与质量，不断地尝试通过并行编程技术针对一些优秀的理论以及数据处理算法进行试验与改进，并且在实践过程中出现了在大型集群系统（如：超级计算机）中同时使用两种或多种并行编程模型和框架的趋势。然而由于专业知识的限制、程序并行性分析工具的局限性以及多种并行编程模型和框架在结合使用的同时缺少统一的标准编程接口，使得上述相关领域的从业人员在串行程序的并行性识别和并行程序开发方面均存在着较大的困难。这直接导致了行业经验、专业技能、数据处理需求与实际处理效率之间的不对称关系。因此，上述众多领域迫切的需要更加通用快捷的串行程序并行性识别工具和更加统一易用的并行编程标准接口，来降低并行编程的技术门槛，提高数据处理的效率，避免计算资源的浪费。\r\n不难发现，上述两大需求中，如何更好的识别串行程序的并行性，即从串行程序中识别出可以并行化的程序片段，才是更好的进行并行程序开发的前提和基础。关于串行程序的并行性识别，传统的做法是基于程序的静态分析技术或动态分析技术，收集程序的语义信息、相关语句的数学表示以及程序的运行时特征，采用线性整数规划或逻辑回归策略，重点关注和分析程序中循环片段的并行性。但传统手段由于相关数学理论限制或收集信息的时间问题，在处理结构复杂、计算量大、数据密集并且运行时间长的应用程序时表现并不理想，而上述特点正是生产和科研领域实际应用程序的普遍特征。如何最大程度的打破传统方法的局限性，提供快捷、准确并且简单易用的串行程序的并行性识别方法，是高性能计算领域的一大重点研究方向。\r\n近几年来，深度学习技术在自然语言处理（NLP）领域得到了广泛应用并取得了巨大的成功[6]，这推动了NLP技术在程序源码分析领域的应用和推广。众所周知，自然语言拥有词、短语、句子、段落、文章的层级结构；类似的，程序源码拥有关键字、表达式、选择/分支/循环结构、函数、再到整个程序的层级结构。因此，可以将程序源码认为是计算机世界的自然语言。研究者们从代码的语义信息出发，通过对代码的抽象语法树（AST）、中间表示（IR）、编译后的二进制文件、控制流程图（CFG）、数据流程图（DFG）等各种表示形式进行词嵌入相关的研究，提供了将程序源码转换为深度学习所需的数据组织形式——向量的不同方法。并通过不同的深度学习模型完成了诸如变量名/函数名预测、代码补全、恶意代码检测、内存溢出风险检测、算法程序分类等众多源码分析任务且效果显著。可见，深度学习在程序源码分析领域同样具有巨大的潜力与活力。对于识别串行程序的并行性而言，深度学习的方法直接以程序源码为数据，无需深入分析程序的静态语义，无需收集程序的运行时特征，在很大程度上打破了传统的程序并行性识别方法的局限性。使用深度学习的方法自动识别串行程序的并行性，是一个全新的研究方向。\r\n1.2国内外研究现状\r\n如1.1节所述，串行程序的并行性识别，是并行程序开发中的首要环节也是本文的重点研究内容之一。深度学习技术在源码分析领域的应用经验，也为将深度学习的方法应用至串行程序的并行性识别研究提供了可行性参考。本节将分别从国内和国外两个方面列举并介绍近年来外关于串行程序并行性识别的相关研究和深度学习技术在程序源码分析领域的相关研究。\r\n1.2.1国内研究现状\r\n在国内，程序的并行性分析是一个老生常谈的问题。2002年，乐晓波、汪琳等人将Petri网相关技术应用到循环的并行性分析中来。在数据相关性的分析过程中使用Petri网理论，从全局的观点出发，分析同一数据与所有语句的相关性，从而提出了将串行程序转换为并行程序的有效方法[7]。2007年，蒋作、高毅结合相关并行技术与定义，提出了能够把串行程序中可以并行执行的片段识别出来的PARALLELIZING算法[8]。2009年，梁博、安虹等人详细分析了线程级推测技术在子程序结构上的适用性并提出了其判定依据，通过动态剖析工具对该判定依据进行了详细的实验分析和论证[9]。2010年，闫昭、刘磊对串行程序中的基本块进行了数据依赖分析，提出了一种自动并行化方法，对不存在数据依赖的基本块进行并行优化，较大程度地解决了串行程序在并行计算机系统中的运行效率问题[10]。2011年，郭慎、李培峰等人利用支持向量机对程序的静态特征和动态特征进行特征挖掘，提出了一种基于特征的程序并行性识别方法 [11]。2013年，王磊、曲卫平、李敬兆研究了自动并行化中的前端分析技术，引入并改进了人工智能搜索方法，实现了在评估函数的支持下进行广度搜索和深度搜索的方法[12]。2017年，王家龙、刘艳红、沈立面向一个高效的软件TLS模型HEUSPEC，研究了代码自动生成工具C2H的设计与实现方法。该方法已在开源编译器Clang上实现，基于该方法对Rodinia、OmpScr等基准程序的测试结果表明，C2H能够将带有简单标注语句的串行C代码转换为HEUSPEC并行代码，且其性能与手工编写的HEUSPEC并行代码的性能十分接近[13]。2018年，王时雨、张胜兵等人基于LLVM编译架构，提出了一种针对图像处理类程序的可并行性分析方法，从程序中的数据依赖关系和可并行特征两个方面对程序中的循环进行分析，实现了图像处理类程序的自动并行分类[14]。将深度学习的方法应用至源码分析研究在国内则是一个较新的研究方方向，2019年，谭丁武、张坤芳等人提出了一种程序的中间表示——ESAST图，并基于该图提出门控注意力图神经网络模型，对给定的源码程序进行了高精度的算法分类[15]。\r\n1.2.2国外研究现状\r\n国外对于程序的并行性分析更趋向于编译优化、提出软件架构和源到源转换等方法。2008年，Uday Bondhugula、J. Ramanujam提出了一种基于Polyhedral多面体模型的整数线性优化算法，并由该算法驱动实现程序源到源转换框架Pluto，该框架可以发现串行程序中的并行性和局部可优化部分，并提供向C/C++源码中加入OpenMP标记的功能[16]。这是对Polyhedral模型的一次优秀实践，与其他相关研究[17~20]一起证明了Polyhedral模型对于程序优化的实用性。2012年，Javier Diaz等人调查和分析了当时常见的并行编程模型和工具对高性能计算领域的适用性，发现混合并行编程可以更好地利用计算机集群功能，而异构编程也由于多核CPU+GPU架构的流行而越来越普遍[21]。2013年，Daniel Fried等人研究了一种自动分类方法，利用监督学习算法对NAS并行基准测试集（NPB）进行学习和分类，较为全面的比较了支持向量机、决策树等在程序并行性分类问题上的性能表现[22]。2016年，Zhen Li等提出了一个基于动态程序分析的通用并行性框架DiscoPoP，框架以计算单元（CU）为基础概念，将程序表示为CU图，提供了与编程语言无关的高效的数据依赖分析工具[23]。David del Rio Astorga等人提出了一种有助于发现和自动标注程序源码文件中Pipline并行模式片段的图形分析工具PPAT，极大的促进了串行代码到并行代码的转换效率[24]。同年，该团队对PPAT进行扩展和改善，添加了对Map、Farm并行模式的支持，简化了源到源转换的流程[25]。2018年，Haibo Zhao、Fei Zheng等人提出了一种可以识别二进制文件中的可并行部分并自动将其并行化的方法，扩展了现有编译器的编译优化技术，为进一步提高程序性能做出贡献[26]。\r\n国外基于深度学习方法进行源码分析的研究同样活跃。2015年，Lili Mou，、Ge Li等人提出了一种基于程序抽象语法树结构的卷积神经网络TBCNN，并通过实验验证了相较于其他NLP神经网络模型，TBCNN在程序分类问题上更加有效[27]。2017年，Vincent J. Hellendoorn Min-je 等人对深度神经网络模型是否是源代码建模的最佳选择进行了深入探讨[28]。同年，Choi、Sehun Jeong等人提出了一种以数据驱动的、完全端到端的检测代码缓冲区溢出的方法，该团队使用程序模板自动生成大量带有标注的数据集，通过记忆网络模型对数据集进行学习与分类，实验证明，该模型在检测程序缓冲区溢出的问题上表现优异[29]。2018年，Carson D. Sestili等人在文献[29]的基础上，利用记忆网络模型，针对缓冲区溢出问题检测与现有静态分析工具进行对比，并致力于为未来可能解决的问题如为深度学习提供更合适的数据等[30]。Uri Alon等人提出使用抽象语法树中的路径表示一段程序，来代替将程序作为一个简单的序列地做法，通过训练神经网络实现了对程序中变量名称的预测[31]。同年，ALON和他的团队提出了基于抽象语法树对源代码进行嵌入表示的code2vec模型，用于将代码片段表示为连续分布的向量，能够更加准确的学习代码语义[32]。此外，Miltiadis Allamanis等人在2018年建议使用图来表示代码的语义结构，并提出使用基于图的深度学习方法对程序结构进行推理[33]。Tal Ben-Nun等人在他们的论文中，提出了基于中间表示的可学习代码语义表示NCC，将程序编译为LLVM IR然后再通过建立程序上下文流图（XFG），使用图嵌入的方法对代码进行嵌入表示。相较于直接处理代码或使用抽象语法树对代码进行嵌入的方法，NCC在算法分类等问题上具有更加表现[34]。2019年，Zimin Chen等人对现有的源代码嵌入方法进行了总结和介绍，详细分析了NLP技术在源码分析领域中的应用现状[35]。\r\n1.3本文的主要工作\r\n本文基于深度学习及相关技术，研究了一种串行程序的并行化方法，从串行程序的并行性识别、并行程序开发、并行程序调试三个方面提供了完整的串行程序并行化方案。主要工作包括以下4个部分：\r\n（1）构造了数据集GFCPD，该数据集不仅覆盖了Livermore、NPB等常见的并行程序基准测试集，同时包含了常用数学程序库以及图的相关算法、树的相关算法等复杂算法的不同实现。是一个基于程序上下文流图（XFG）的通用数据集，是一个可以用于串行程序并行性识别任务的深度学习数据集。\r\n（2）建立了基于深度图卷积神经网络模型架构（DGCN）的串行程序并行性识别模型，并将该模型的识别结果同传统的静态分析方法、结合动态特征的机器学习方法以及在算法分类问题上表现良好的深度学习模型进行对比，从而验证了DGCNN在串行程序的并行性识别任务中的可行性与有效性。\r\n（3）基于XML技术实现了并行编程标记语言PML，对MPI、OpenMP等现有编程模型进行设计与封装，提供统一的标准化编程接口，简化了并行编程方式，降低了并行编程门槛。\r\n（4）实现了并行编程辅助平台，集成了串行程序的并行性识别、PML语言的程序开发、并行程序的远程调试等功能，提供友好的用户交互环境与完整的并行程序开发流程。\r\n1.4本文的组织结构\r\n第一章为绪论。介绍了本文课题的背景和意义，分析了近年来国内外对于串行程序并行化方面的研究与深度学习方法在源码分析领域的应用现状，对本文的组织结构及主要工作内容做了简要的介绍。\r\n第二章简要介绍了本文研究中相关的理论和方法，包括程序的并行性分析、LLVM编译器框架、程序的上下文流图（XFG）、Polyhedral模型、pluto编译器和图神经网络。\r\n第三章主要介绍数据集GFCPD（Graphs For Code Parallelism Discovery）的构造过程，对数据集的代码成分分布、构造流程及数据集规模的合理性进行了详细的介绍。\r\n第四章是本文的重点研究内容，对深度学习方法在串行程序并行性识别的研究中是否可行进行了分析，提出了一种将GFCPD数据集应用于深度学习任务的数据预处理方法，建立了基于深度图卷积神经网络的串行程序并行性识别模型，并通过对比实验分析了本文建立的识别模型相较于其他方法的优劣性。\r\n第五章介绍了如何将本文所有的工作转化为完整的程序并行化方法。主要包含了两部分的内容，首先介绍了基于XML的并行标记语言PML，说明了其设计思路与实现细节；然后介绍了并行编程辅助平台，列举并展示了其基础功能的实现技术与实现效果，叙述了如何将串行程序的并行性识别特性集成到平台中，形成完整的并行程序开发流程。\r\n结论中分析了本文所作研究的成果和局限性，对本文的研究工作进行了总结，为下一步的研究工作指明了方向。\r\n第2章相关理论与方法\r\n2.1程序的并行性分析\r\n并行编程在实际工程应用中占有着举足轻重的位置。尤其在地震数据处理、物理模型计算等科学计算领域具备着巨大的应用潜力。对于计算机程序而言，并行性可以分为控制并行性和数据并行性。前者是将程序划分为多个可独立执行的部分，每个部分对相同的一份数据同时执行不同的操作；而后者则是将数据划分为多个部分，使用多个相同的程序同时处理不同的数据。若想要将串行程序改写为并行程序，使得计算机可以同时正确的处理多个任务或快速高效的处理庞大数据，从而提高程序执行的效率，以达到节约时间成本和充分利用计算资源的目的，首要任务则是关注程序中的依赖关系，进行串行程序的并行性分析。\r\n2.1.1数据依赖与控制依赖\r\n数据依赖和控制依赖的存在与否往往决定了程序是否具备并行性。本小节将介绍它们并讨论它们在程序并行性分析中所扮演的角色。\r\n一般来讲，如果一个循环中不存在控制语句（即不存在控制依赖），且循环体中的语句无论如何变换执行顺序，循环的执行结果都不会改变，则认为这个循环是可以并行化的。因此，关于循环内的数据依赖关系分析，主要针对三种依赖形式：流相关、反相关和输出相关，如图2.1所示。图2.1（a）中，语句S1对元素A[i]进行写操作，语句S2对元素A[i]进行读的操作，语句S1先于语句S2执行。语句S2中A[i]的输入值依赖于语句S1中对A[i]的操作结果，因此，必须保证语句S1和S2的先后顺序，才能保证程序执行结果的正确性，此时称语句S1和语句S2之间存在数据流相关依赖关系；图2.1（b）中，图2.1（b）中，语句S1对元素C[i]先执行读操作，随后语句S2对元素C[i]进行写操作，必须保证语句S1先于语句S2执行，才能保证语句S1每次都能读到正确的C[i]值，此时我们称语句S1与语句S2存在数据反相关依赖关系；图2.1（c）中，语句S1和语句S2均对元素A[i]执行写操作，此时若想保证程序执行结果正确，仍需保证语句S1先于语句S2执行，此时称语句S1与语句S2存在数据输出相关依赖关系。\r\n如果循环中存在控制语句，即后一条语句执行与否依赖于前一条语句的执行结果，则称该循环中存在控制依赖。如图2.2（a）所示，语句S2与语句S1之间存在控制依赖，而语句S3与语句S1之间不存在控制依赖，因为语句S3无论如何都会被执行。值得一提的是，控制依赖不同于控制流，参考图2.2（b）和图2.2（c）可知，控制流图描述了一个程序的执行路径，通常编译器可以生成控制流图并从中导出控制依赖关系。不难发现，与数据依赖类似，控制依赖也会在语句间形成执行顺序的约束，但控制依赖可以通过一种叫做预测执行的技术被消除。因此，在对串行程序进行并行性分析时，往往主要关注其中的数据依赖关系。\r\n图2.1 数据依赖关系示例图\r\n图2.2 控制依赖关系示例图\r\n2.1.2静态分析与动态分析方法\r\n串行程序的并行性分析之所以具有挑战性，主要是因为不能既准确又高效地得到程序中的依赖关系。常见的程序并行性分析方法按照是否收集程序运行时的相关信息，可以分为静态分析方法和动态分析方法。\r\n程序的静态分析无需运行代码，是一种直接从程序代码或中间表示（IR）中提取静态特征进行分析的代码分析技术，可以在一定程度上高效地验证代码是否满足既定的各项指标。常见的程序静态分析技术有：（1）词法分析，其目的是将源程序转换为Token流，并生成一个相关的符号列表；（2）语法分析，通过将上述符号列表转换为抽象语法树，来判断源程序的语法结构是否正确；（3）语义分析，对语法结构正确的源程序进行语义方面的正确性检查；（4）控制流分析，生成有向的控制流图，用节点表示代码的基本块，节点间的有向边代表控制流路径和可能存在的循环。分析过程中可以生成函数调用关系图，来表示函数间的嵌套关系；（5）数据流分析，在程序中各个初始化点和引用点上，对变量的可能值信息进行收集和分析。\r\n在很多情况下，纯静态的程序分析被证明是过于保守的，因此出现了一系列的动态分析方法。动态分析关注的是程序运行时的真实行为，捕获程序实际运行时的依赖关系。具体的来说，通常有三种方式可以记录程序运行时的信息，追踪程序变量并记录、使用插桩技术[36]或者结合使用前两者。其中插桩技术是常用方法之一，根据实际需要在不同阶段或不同的代码级别上加入辅助代码，按照插桩、执行、分析的三部曲对程序进行动态分析。\r\n程序的静态分析方法在生成程序的数据流图和控制流图方面存在速度与质量的双重优势，但是静态分析方法往往在评估程序的并行性时被认为是保守的。这是因为：首先，当程序规模足够庞大且分支较多时，依赖分析的搜索空间会成几何倍增长；其次，它所用到的信息有限，在分析只有在运行时才会动态分配空间的对象之间的依赖关系问题上存在短板。与之相反，动态分析方法在程序运行时跟踪检测程序中的依赖关系，它仅仅对程序运行时确实存在的对象进行分析，不受分支数量的影响，因此动态分析过程中的数据流图和控制流图是不完整的，它的分析结果也可能取决于某种程序执行的配置，且在某些时候在时间和空间上都有很高的运行开销。\r\n2.1.3并行性分析工具\r\n如前文所述，发掘串行程序的并行性的实际需求是寻找程序中的数据依赖关系。当目标程序规模足够庞大，代码行数足够多时，通过手动的方式寻找程序中的数据依赖关系是不现实的，因此基于数据依赖关系理论自动预测串行程序的并行性是十分必要的。本小节中，将现有的程序并行性分析工具按照数据依赖分析器、半自动并行化工具和自动并行化工具三种类型进行了罗列（如表2.1所示）。\r\n表2.1 现有并行性分析工具信息表\r\n类别 名称 定义数据依赖分析器 Aristotle Analysis ystem[37] 负责分析并揭示程序中的数据依赖关系，但不提供并行化指导，由用户通过依赖关系分析结果确定程序的并行性。\r\nFrama-C[38]DMS® Software Reengineering  Toolkit™半自动并行化工具 Kremlin[39] 尝试在串行程序中发现潜在并行性的位置，但不显示数据依赖关系，也不对源程序进行修改，仅在程序的可并行部分对用户进行提示。\r\nAlchemist[40]Parwiz[41]Tareador[42]Intel® Advisor XE[43]SLX Tool Suite[44]Prism[45]自动并行化工具 Intel® C++ Compiler 自动分析并发现串行程序中的并行性，并自动将源串行程序转换为并行程序。\r\nPolly[46]LRPD test[47]Apollo[48]ParallWare[49]Par4All[50]PLUTO[51]Cetus[52]必须说明的是，尽管串行程序的并行性发现工具相关研究十分活跃，一些基于Polyhedral模型或推测执行机制对循环结构进行并行性发现和源到源转换的工作也实现了完全自动化，但由于实际应用程序具有不规则的执行模式和不同的运行规模，这些方法和工具仍然在时间、能耗、适用范围等方面存在限制性。因此，目前仍然没有适用于实际应用程序的通用且成熟的并行性发现工具。此外，静态分析仍是目前较为先进的工具中使用最广泛的方法，表2.1所列工具中只有Intel Advisor XE和Cetus使用了程序的运行时数据。\r\n2.2 LLVM编译器框架与IR\r\nLLVM（Low Level Virtual Machin，底层虚拟机）为任意编程语言静态和动态的编译目标提供了支持，是一个基于SSA的现代化编译策略。显然，其范围早已并不局限于创建一个虚拟机[53]，如今LLVM已经发展成为了一个模块化和可重用的编译器和工具链技术的集合，用于优化任意程序语言源码的编译时间、链接时间、运行时间以及空闲时间。\r\nLLVM核心库为编译器提供了相关支持，可以作为多种编程语言的编译器后台。传统的静态编译器（例如大多数C编译器）采用如图2.3所示的前端、优化组件和后端的三段式设计。前端组件解析程序源代码，检查语法错误，生成一个基于语言特性的抽象语法树（AST）来表示输入的代码。AST将代码转换为具有新的表达语法的中间代码提供给优化器，然后优化器和后端程序将中间代码翻译成机器代码。需要说明的是，传统静态编译器对于不同的编程语言和硬件架构分别设计了不同的中间代码表示，而LLVM对这三个阶段采用了更加合理的设计。如图2.4所示，LLVM对于不同的前端和后端均使用统一的中间代码（LLVM IR）表示。如此一来，使编译器支持一种新的语言就仅仅需要实现一个新的前端；同理，使编译器支持一种新的硬件设备，仅仅需要实现一个新的后端。优化器则是一个通用的组件，它针对的是统一的LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化器做出修改。\r\n图2.3 传统静态编译器架构示意图\r\n图2.4 LLVM架构示意图\r\nLLVM IR本质上是一种与源编程语言和目标机器架构无关的通用中间表示，是LLVM项目的核心设计和最大的优势。它使用静态单赋值（SSA）策略，即以三地址码的形式组织指令并且假设有无数个寄存器可用（为每一个变量、基本块或函数提供唯一的标识符，但标识符名称不确定）。它是经过特殊设计的，并且为了支持轻量级的运行时优化、过程函数的优化、整个程序的分析和代码完全重构以及翻译等等，它还定义了清晰的语义。假设有一段C语言程序如图2.5（a）所示，那么其对应的IR如图2.5（b）所示。可以看出，LLVM IR 是一种底层的类RISC虚拟指令集。正如真正的RISC指令集一样，它提供了一系列线性的简单指令，如加、减、比较和分支结构等等。和大多数RISC指令集不同的是，LLVM使用了一种简单的数据类型系统来标记强类型（如使用i32表示32位整型，使用i32**表示指向32位整型的指针），而一些机器层面的细节都被抽象了出去（如函数调用使用call作标记，而返回使用ret标记）。\r\n图2.5 LLVM IR示例图\r\n2.3程序的上下文流图（XFG）\r\n程序的上下文流图，是由Tal Ben-Nun等人在文献[34]中提出的首个以通过结合程序中控制流信息与数据流信息来生成程序指令嵌入（即向量表示）的图表示形式。其中，上下文是指相互之间存在依赖关系（包括数据依赖和控制依赖）的语句，同时为了在生成嵌入过程中避免硬件特性、编程语言特性和指令组装等方面的限制和歧义，选取独立于硬件和编程语言的LLVM IR作为图构造过程的数据来源。\r\n由于LLVM将IR语句划分为“基本块”，每个基本块中不存在控制流分支。如图2.6（c）所示，不同的矩形框代表不同的基本块，在一个基本块内，程序按顺序执行并创建可追踪的数据流，同时将执行结果分配给单个标识符，因此一个基本块内的数据依赖关系清晰可见，基本块内任何标识符的上下文也很容易可以获得。但是在控制分支前后，仅靠数据流图并不足以提供足够的信息来确定给定标识符的程序上下文。XFG恰好弥补了这一缺陷，其中既包含了数据流信息也同时包含了控制流信息。如图2.6（d）所示，XFG是有向多重图，其中两个节点之间可以拥有多条边。 XFG的节点可以是变量、基本块或函数名称等标识符，在图中分别显示为椭圆形或矩形。相应地，一条边代表一种数据依赖（黑色）或控制依赖（浅蓝色）。\r\n图2.6 XFG示例图\r\n由于LLVM IR中对标识符名称的分配是不确定的，因此上述使用标识符作为XFG节点的表示方法使得XFG节点的表示空间变得无限大。为了更加贴合上下文的概念和更好的学习代码的嵌入表示，文献[34]的实验过程中，在假设相同上下文中出现的语句大概率具有相似的语义的前提下，对LLVM IR语句的类型进行了总结并将XFG中的节点向IR语句级别进行了二次整合生成了Dual-XFG，使其所有的节点均为LLVM IR语句，即LLVM IR文件中的一行。除非特殊说明，本文接下来所提到的XFG均指Dual-XFG。\r\nXFG的构造遵循以下规则：（1）一个基本块内的数据依赖关系必须全部用边进行连接；（2）基本块与基本块之间的依赖关系必须使用边将基本块标识符相连接；（3）没有父级数据流入的基本块，与图的根节点相连；（4）对于外部代码调用，若为静态调用，在编译过程中可以访问代码，则将该部分代码语句包含在XFG中，若为动态链接，在编译过程中不可访问代码，则使用调用语句代替。值得一提的是，对于一个有n个SSA语句的LLVM IR文件，构造其XFG的时间复杂度为O（n），这说明了使用XFG进行程序语义的表示对于大规模代码（如Tensorflow源码）的分析具有巨大价值。\r\n2.4 Polyhedral模型和Pluto编译器\r\n在国内关于Polyhedral模型的研究中，多将其译为多面体模型。由于多面体模型具有应用范围广、表示能力强和优化空间大的优点，目前基于多面体模型的编译优化技术是串行程序自动并行化研究领域的一个热点， 是解决串行程序自动转换为并行程序的一种有效手段[54]。\r\n基于多面体模型的编译技术在满足循环的上下界约束条件的前提下，以空间内的多面体形式表示程序语句， 通过在该多面体上进行的几何操作对程序特征进行分析并对程序性能进行优化。多面体模型将程序及其语义表示为迭代空间、访存映射、依赖关系以及调度。其中， 迭代空间是指在循环的一次迭代内，随着迭代变量（i或j等等）变化的某一条语句（如：A[i]=B[i]+C[i]）的所有实例的集合（如｛A[i]=B[i]+C[i]，（i=0,1,2…n）｝）；访存映射用于表示内存访问操作与程序语句之间的对应关系；依赖关系是指访问相同内存地址的两个程序语句实例之间的偏序关系（其中至少有1个操作类型为写操作）；调度则是在依赖关系的约束下对语句实例之间执行顺序的表示。如图 2.7（a）所示循环片段， 其多面体表示如图2.7 （b）所示， 蓝色空心圆形表示语句S1的实例， 红色实心圆形表示语句S2的实例； 图 2.7（c）中列出了该循环片段对应的迭代空间（Domain）、调度（Schedule）、访存映射（Write and Read）和依赖关系（Dependence）。\r\n图2.7 Polyhedral模型示例图\r\n20世纪90年代以来，基于Polyhedral模型的编译技术在程序自动并行化研究领域取得了诸多成果，甚至在许多方面可以代表这一领域目前最先进的水平。基于Polyhedral模型的编译工具的工作流程如图2.8所示，其中红色虚线框内的部分是其主要构成组件。首先，编译工具的前端由抽象分析组件构成， 其作用是根据多面体模型的静态仿射约束从输入的程序源码中识别并提取满足条件的程序片段， 同时将其表示成多面体的形式；然后，以迭代空间和访存映射为依据，调用整数线性规划组件计算其中的依赖关系。这里的静态约束是指某一个程序段中的控制流和依赖关系在编译阶段可以被判定并且能够用有限的集合进行表示。编译工具的中间优化部分由调度变换组件构成， 其作用是通过调用整数线性规划组件， 计算得到一个既满足依赖关系又可以充分发挥目标程序性能和利用硬件体系结构特点的调度结果。最后，编译工具的后端由代码生成组件构成， 该部分的功能又可以分为两个阶段：第一阶段借助整数线性规划组件，将迭代空间和调度结果转换生成AST； 第二阶段将AST转换为符合目标程序语言语法规范的最终代码。\r\n图2.8 基于多面体模型的编译工具工作流程示意图\r\nPluto编译器是一个很好的开发程序并行性和数据局部性的优化工具，是众多基于Polyhedral模型的编译器中应用范围最广、最成功的编译器之一，以该编译器为平台实现的Pluto调度算法和Pluto+算法代表了Polyhedral模型调度最先进的研究水平。文献[16]也因此于2018年被PLDI （ACM SIGPLAN Conference on Programming Language Design and Implementation） 会议以“Pluto调度算法至今在众多领域包括将机器学习算法部署在特定加速部件等方面都发挥着重要作用”的评语评为近十年最有影响力的论文。\r\n从编程语言的层面来讲，Pluto编译器是一个从C语言程序到OpenMP程序的源到源编译器，并且自开源以来不断地尝试兼容包括PIP、ISL、PET、Clan等在内的各种开源库。从优化角度来看，Pluto算法的实现思路决定了Pluto编译器是一个试图使用调度来尽可能多的解决程序并行化中遇到的优化问题的工具。在程序的分析方法层面，Pluto编译器是一个仅支持C语言文件作为输入的静态分析工具。此外，Pluto编译器还可以被用来开发程序多粒度的并行性，比如对于存在嵌套循环的程序段，可以将外层的循环做OpenMP并行标识，而将最内层可以进行向量化的循环做ivdep和vector always标识，然后再交给基础编译器做进一步的向量化开发。遗憾的是，由于前文提到的Polyhedral模型本身对于程序静态约束的要求，Pluto编译器目前还没有办法直接用于大型应用测试集的优化。\r\n2.5图神经网络与图卷积神经网络\r\n虽然深度学习已经在欧几里得空间数据中取得了很大的成功[55]，但越来越多的应用程序数据开始以图的形式进行表示，大量的学习任务要求处理元素间含有丰富关系信息的图数据。如物理系统的建模、分子指纹的学习、蛋白质结构的预测和疾病的分类等都需要模型从图数据中去学习，但传统的神经网络模型并不能很好的处理图类型的数据，图神经网络（GNN）应运而生。GNN的概念是由Gori等人首次提出的[56]，后来的研究人员在设计GNN的架构时又借鉴了卷积网络（CNN）的思想，出现了图卷积神经网络（GCN）。\r\n2.5.1图的定义\r\n近年来，由于图的强大表达能力，用机器学习方法分析图的研究受到了越来越多的关注。图是一种对一组对象（图的节点）及其之间的关系（图的边）的集合进行建模的数据结构。在计算机科学中，一个图G可以由它所包含的顶点和边的集合来进行描述。而在机器学习领域，由于图的数据复杂且规模并不确定，往往需要将图的邻接矩阵加入到图的定义中来，具体定义如下：定义图G=（V,E,A），其中V代表图的节点集合，E代表图的边的集合，A代表图的邻接矩阵。在一个图中，vi∈V表示一个节点，eij=（vi,vj）表示一条边。对于一个具有N个节点的图G来说，它的邻接矩阵A是一个N*N的矩阵，Aij表示图的第i个节点vi和第j个节点vj之间的关系，如果Aij>0则两个节点间存在一条边eij，Aij=0则不存在。根据顶点之间的边是否存在方向依赖关系，图可以分为有向图和无向图。如图2.9（a）所示，有向图G=（｛v1，v2，v3}，｛e12，e23，e31，e32}，A），其中A如图2.9（b）所示。\r\n图数据的复杂性对现有机器学习算法提出了重大挑战，因为图数据是不规则的。每张图大小不同、节点无序，一张图中的每个节点都有不同数目的邻近节点，使得一些在图像中容易计算的重要运算（如卷积）不能再直接应用于图。此外，现有的机器学习算法默认其数据实例是彼此独立的。然而，图数据中的每个实例都与周围的其它实例相关，含有一些复杂的连接信息，用于表示数据之间的依赖关系。\r\n图2.9 有向图及其邻接矩阵示例图\r\n2.5.2GNN简介\r\n图神经网络（Graph Neural Networks，GNN）是在图域上运行的深度学习方法。近年来，GNN较好的可解释性和其在图数据分析中表现出的超高性能使其成为了一种广泛应用的图分析方法。GNN是一种连接模型，它通过图的节点之间的消息传递来捕捉图的依赖关系。与标准的神经网络不同的是，图神经网络保留了一种状态，可以表示来自其邻域的具有任意深度的信息。虽然原始的 GNN很难为一个固定点进行训练，但是网络结构、优化技术和并行计算的最发展已经使它们具备了学习的能力。\r\nGNN的学习目标是通过迭代获得每个节点的隐藏状态 ，其中包含了来自相邻节点的状态信息。为了更好的理解图神经网络如何使每个节点都能感知到图上的其他节点，接下来就某一时刻图神经网络节点状态的更新与输出做如下简要说明：给定一张图 G，每个节点v都有其自己的特征和隐藏状态，节点v与节点u之间的边也具备特征。那么在t+1时刻，节点v的隐藏状态将按照式2.1的方式更新。其中，是隐藏状态的状态更新函数，指的是与节点v相连的所有边的特征，指的是节点v的所有邻节点的特征，则指节点v的所有邻节点在t时刻的隐藏状态。需要注意的是，是一个全局共享的函数，是对所有节点都成立的。以图2.10为例，假设某一时刻节点5为中心节点，其隐藏状态的更新函数如图所示。其中，，分别是节点3、5、6的特征，对应式2.1中的；、是与节点5相连的两条边的特征，对应式2.1中的；而、则是节点3和节点6的隐藏状态，对应式2.1中的。如此不断地利用当前时刻中心节点的邻节点的隐藏状态作为部分输入来生成下一时刻中心节点的隐藏状态，直到每个结点的隐藏状态变化幅度很小，整个图的信息流动趋于平稳，每个结点也就都感知到了其邻节点的信息。\r\n（式2.1）\r\n图2.10 GNN状态更新示例图\r\n状态更新公式仅仅描述了如何获取每个节点的隐藏状态，除此以外，往往还需要另外一个函数来描述如何适应下游任务。如在节点分类问题中，需要根据节点v最终时刻的隐藏状态按式2.2所示的方式得到其输出用于分类任务。其中，又被称为局部输出函数，与类似，也是一个全局共享的函数。\r\n（式2.2）综上，GNN的节点状态更新和输出整体流程如图2.11所示。可以很清楚的看到，每一时刻的节点状态都与前一时刻其邻节点的状态密切相关。如T1 时刻，因为结点 1 与结点 3相邻，所以节点1在T1时刻的状态更新过程接受节点 3 上一时刻的隐藏状态作为输入。直到 Tn时刻，各个节点隐藏状态收敛，每个结点后面接一个输出函数即可得到该结点的输出。需要说明的是，对于不同的图来说，其节点隐藏状态收敛的时刻可能不同。\r\n图2.11 GNN状态更新与输出流程示例图\r\n2.5.3GCN简介\r\n作为GNN的一种特殊架构，图卷积神经网络（GCN）将常用于图像处理的卷积神经网络（CNN）应用到了图数据相关的深度学习研究中，它为图数据的处理提供了一个崭新的思路，由Thomas Kpif于2016年首次提出[57]。\r\n与CNN类似，可以将GCN中的卷积理解为在局部范围内的图节点特征抽取方法，这里的局部指的是中心节点及其邻节点的集合。如图2.12（a）所示，如果把图像中的每个像素点视作图的一个节点，一张图片也可以看作是一个非常稠密的图。图2.12（b）则是一个普遍意义上的图结构，阴影部分代表卷积核。不难发现，在以图像为代表的欧几里得空间中，每个节点的邻节点数量都是固定的。如图2.12（a）中任何节点的邻节点始终是8个（边缘上的节点可以做填充）。但在图这种非欧几里得空间数据中，节点的邻节点数量并不固定。如图2.12（b）中绿色节点的邻节点有2个，但同时存在某个节点有5个邻节点的情况。欧式空间中的卷积操作实际上是用固定大小可学习的卷积核来抽取像素的特征，但由于图中节点的邻节点数量不固定，所以传统的卷积核并不能满足图数据处理的需求。\r\n因此，图卷积神经网络的本质是提供了适用于图的可学习的卷积核用于抽取图上节点的特征。与上文提到的GNN相比，同样是结合邻节点的状态信息来更新中心节点的状态，且同样具备局部输出函数来完成更多的下游任务（如节点分类等）；不同的是，GNN通过多次循环迭代以达到节点的隐藏状态收敛的目的，每次迭代的参数（即状态更新函数）是全局共享的，而GCN则是以卷积的方式通过卷积层堆叠，不同的卷积层根据任务需要可以采用不同的参数，完成节点状态的更新。\r\n图2.12 卷积核示例图\r\n2.6本章小结\r\n本文的研究内容将深度学习与串行程序的并行性识别相结合，为了使后续章节中的内容更加清晰易懂，本章除了对研究过程中使用到的编译工具、程序语义表示方法给出具体的说明外，在串行程序的并行性分析方面，简要解释了串行程序并行性分析的概念与意义，对串行程序并行性分析过程中重点关注的数据依赖与控制依赖的概念做了详细阐述，对程序的静态分析方法和动态分析方法进行了简要说明，并对现有的程序并行性分析工具做了分类罗列；在深度学习方面，重点介绍了后续实验过程中使用到的图神经网络及图卷积神经网络的相关概念与理论。\r\n第3章 GFCPD的构造\r\n所谓兵马未动，粮草先行。众所周知，在深度学习相关的研究中，输入数据的质量在很大程度上决定了实验的结果好坏。可见数据在深度学习相关研究中的地位无异于粮草之于兵马。由于目前并没有合适的深度学习数据集可以直接用于串行程序并行性识别的研究，为了更好的将深度学习方法应用到本文的研究中来，本章构造了一个适用于串行程序并行性识别任务的深度学习图数据集GFCPD。GFCPD是一个基于XFG的通用图数据集，本章详细介绍了其构造过程中数据搜集、数据提取、数据标注以及XFG的生成四大阶段，并对其规模进行了论证和说明。在开始接下来的几个小节之前，为了避免下文叙述中的逻辑混乱，需要提前对本章工作的文件夹目录结构做如图3.1说明。\r\n图3.1 第3章工作目录结构说明图\r\n3.1数据搜集\r\n数据搜集是GFCPD数据集构造的先导工作，为了使本数据集以及接下来基于本数据集所做的相关研究具备普适性和可靠性，数据搜集工作主要分为基准测试程序、现有数学运算程序库和一般程序三个方面进行。本小节接下来的内容将对上述过程搜集到的数据做详细介绍。在此之前需要说明的是，上述过程中搜集的代码均为C/C++语言编写的串行版本代码，按照类别分别存储在source_code文件夹中。\r\n（1）基准测试程序\r\n基准测试程序部分主要考虑了在大多数程序并行性相关研究中均有使用的利弗莫尔循环（Livermore loops）和NAS并行基准测试程序（NPB）。其中，Livermore loops是由Francis H. McMahon从劳伦斯利弗莫尔国家实验室的计算机上运行的科学源代码中创建的。它由24个循环组成（详见表3.1），每个循环运行一个数学核。该基准于1986年发布了Fortran版本，但后来被移植到许多编程语言中。\r\n表3.1 Livermore循环详情表\r\n序号 数学核 序号 数学核\r\n1 流体力学 13 2-D单元格粒子\r\n2 不完全的楚列斯基共轭梯度法 14 1-D单元格粒子\r\n3 内积 15 任意Fortran\r\n4 带状线性系统法 16 蒙地卡罗搜索\r\n5 三对角线性系统法 17 隐式条件计算\r\n6 一般线性递归方程 18 显式流体力学计算\r\n7 状态方程 19 一般线性微分方程\r\n8 交替方向隐式集成 20 离散坐标转置\r\n9 集成预测因子 21 矩阵乘积\r\n10 差异预测因子 22 普朗克定律11 一阶和 23 2-D隐式流体力学计算12 一阶差分 24 数组中最小值的第一个位置NPB是由美国航空航天局发布的一套并行基准，该基准是一个流体动力学计算的程序集合。目前已经成为公认的用于测评大规模并行机和超级计算机性能的标准测试程序。如表3.2所示，本文所使用的NPB版本由8个程序模块组成，包括5个核心程序模块和3个模拟程序模块。\r\n表3.2 NPB详情表\r\n模块名称 简介IS 整数排序EP 计算Gauss伪随机数CG 大型稀疏对称正定矩阵的最小特征值的近似值的求解模块MG 一个简化的多栅格核心基准测试FT 利用快速傅里叶变换来解决3维的偏微分方程BT 求解3对角线方程组SP 求解5对角线方程组LU 利用对称超松弛法求解块稀疏方程组\r\n（2）数学运算库\r\n数学运算程序库部分采用了GNU高精度算术运算库GMP、基础线性代数子程序库BLAS及有效支持线性代数、矩阵和矢量运算、数值分析及其相关的算法的Eigen C++程序库。\r\n（3）一般程序\r\n一般程序部分综合考虑经典并行例程、矩阵操作、图和树的相关算法、动态规划相关算法等方面，主要搜集了如表3.3所示题目的相关实现代码。为了保证数据的正确性和严谨性，对每一份程序源码均进行了代码风格检查及编译测试，对编码格式良好且无编译错误的源码文件予以采用。\r\n表3.3 一般程序详情表\r\n序号 题目 序号 题目\r\n1 函数积分 17 图像平移\r\n2 数字累加 18 图像旋转\r\n3 求解圆周率 19 背包问题\r\n4 埃氏筛法生成质数 20 图的最短路径问题\r\n5 判断质数 21 图的广度优先搜索\r\n6 第K小的数 22 图的深度优先搜索\r\n7 数组求和 23 图的极大独立集\r\n8 N的阶乘 24 N皇后问题\r\n9 矩阵乘法 25 高斯消元法求解线性方程\r\n10 数组前缀求和 26 多重网格法解微分方程11 二分法查找函数零点 27 共轭梯度法的实现12 矩阵转置 28 霍夫变换13 整数集合的缩灭 29 离散傅里叶变换14 快速傅里叶变换 30 K值算法15 遗传算法 31 曼德勃罗特集的计算16 平面凸包问题 32 PSO算法\r\n3.2数据提取\r\n正如2.1所述，循环片段往往是串行程序最具备并行潜力的部分。因此，在数据搜集工作结束后，为了对每一个循环片段分别进行并行潜力识别，本文按照如下步骤对搜集到的源代码文件进行了进一步的提取和处理：首先，将源代码文件中所有的循环片段提取出来；然后，考虑到构造XFG需要将代码文件编译为LLVM IR，又对所有的循环片段进行重构，使每一个循环片段均独立成为一份完整的C/C++代码，以满足编译需求；最后，编译检验重构后的新代码文件，在尽可能多的保留原始数据的前提下同时保证其正确性。本小节接下来的内容将对上述三个步骤进行展开描述。\r\n3.2.1循环提取\r\n由于原始数据的数量较多，为了简化提取工作，缩小时间成本，本文并未借助编译工具的静态分析功能，而是采用面向对象的思想，将程序抽象为图3.2所示结构，利用正则表达式匹配技术，直接从程序源码中提取循环片段。如图3.2（a）所示，从本文所研究内容的角度出发，程序可以看作是函数的集合，而函数又可以看作是循环片段及其他代码的集合。于是将函数抽象为图3.2（b）所示的对象结构，同时将循环片段抽象为图3.2（c）所示的对象结构，并通过fun_name属性将二者相互关联。\r\n图3.2 程序的抽象结构示意图\r\n很显然，提取工作的目标数据是循环片段，但为了方便后面对循环片段的重构工作，本文在循环片段提取过程中第一阶段先将函数从源代码中分离了出来，然后第二阶段将循环片段从函数中再分离出来。同时提取了程序中的函数列表和循环片段以及二者之间的对应关系。提取流程如图3.3所示（图中虚线标号对应下述步骤编号）：\r\n（1）对于每一份源码文件file，首先从中读取所有非空行，存储在列表lines_list中；然后将lines_list中的所有元素使用换行符“\\n”拼接成为字符串对象lines_str；（2）遍历lines_list列表，利用正则表达式匹配该文件中所有的函数定义，按照图3.2（b）所示结构存储所有函数的名称、声明（仅有返回值类型、函数名称、参数列表，不包含函数的具体实现）与其完整的定义（声明+具体实现），得到函数列表fun_list；\r\n（3）遍历列表fun_list，每次迭代处理一个函数对象，在lines_str中将该函数的完整定义使用其声明进行替换；在其完整定义中按照正则表达式规则匹配循环片段并编号，按照图3.2（c）所示结构存储循环片段得到循环列表for_list；同时将函数完整定义中的循环片段以单行注释的形式使用编号进行替换。\r\n图3.3 循环提取算法流程图\r\n至此，循环片段的提取工作宣告完成，提取结果的具体形式如图3.4所示。可以发现，如果一份源码文件中不包含空白行，头文件引用及宏定义共有x1行，定义了x2个函数（包括main函数），那么提取结束后，源程序文件共剩余x1+x2行；如果一个函数共有y1行，其中含有2个循环分别为z1行和z2行，那么提取结束后该函数的完整实现共有y1-z1-z2+2行。在此过程中我们更新了字符串对象lines_str，得到并更新了函数列表fun_list，同时得到了循环片段列表for_list，这三者将是下一步代码重构的重要依据。\r\n图3.4 提取结果示例图\r\n3.2.2代码重构\r\n考虑到构造XFG需要将源码文件编译为LLVM IR，在此部分我们对上述提取过程得到的循环片段按照如下规则进行了重构：（1）保留原程序中的头文件引用、宏定义和变量的声明等内容；（2）每段重构后的新程序中有且仅有一个循环片段（若一个源程序文件提取后包含多个循环片段，那么则将其重构为多个新代码文件）；（3）保留原程序中的函数调用逻辑；（4）最大程度保留原程序语义。不难发现，规则（1）、（3）共同解释了本文在提取循环片段过程中，为何需要不断更新原文件内容lines_str与函数列表fun_list，使用函数的声明对其完整定义进行替换；规则（2）正是本文在提取循环片段过程中，对函数的完整定义中的循环片段使用其编号进行替换的原因所在；而规则（4）则是规则（1）、（2）、（3）存在的理由。具体的重构流程如图3.5所示，其中lines_str、fun_list、for_list为循环提取过程的输出结果。\r\n图3.5 代码重构算法流程图\r\n首先，将搜集到的程序中所涉及到的头文件（。h文件）均放在同一目录headers下并使用正则表达式匹配lines_str中的头文件引用部分，保持其他内容不变的前提下将头文件搜索路径统一修改为“headers/”，把更新后的lines_str内容存为new_file用来构造新的代码文件；然后，遍历循环片段列表for_list，对于每一个循环片段，使用“#pragma scop”和“#pragma endscop”进行包裹标注（由于3.3节使用Pluto编译器进行数据标注的需要），在fun_list中找到其对应的函数对象fun，在fun的完整定义中使用本循环片段替换其对应的注释；接下来，在new_file中使用上述仅包含一个循环片段的fun函数定义替换其声明以构造新的完整程序；最后，为了避免程序命名出现重复和歧义，将重构后的new_file内容作为字符串，采用其长度为5个字节的哈希码作为文件名称并存储在after_extract文件目录中。仍以图3.4所示内容为例，若针对循环片段1进行重构，其重构结果如图3.6所示。\r\n图3.6 重构结果示例图\r\n3.2.3编译检验\r\n为了保证重构后的代码可用，本文在代码重构后对新生成的代码文件使用Clang编译器进行了逐一编译检验。在此过程中，本文使用如图3.7所示的编译命令直接将C/C++源码编译为了LLVM IR文件以便后期使用。为了避免编译器优化对串行程序中关于可并行代码段的特征产生影响，编译选项中的优化等级采用-O0且不附加任何编译优化选项。由于数量较多，本文为编译过程开发了对应的自动化脚本。脚本执行过程中，对于编译通过的代码文件，将其生成的IR文件统一存储在IR/total目录中；对于编译未通过的代码文件，将其编译日志进行记录（logs/compile_error.log）并维护一个产生编译错误的文件列表error_list。在脚本结束后对产生编译错误的文件进行人工核验，根据error_list和编译日志将其中产生编译错误的地方进行人工修正并重新编译；若存在无法人工修正的代码文件，则将其对应的C/C++文件从after_extract文件夹中删除。\r\n图3.7 编译命令\r\n3.3数据标注\r\n数据的标注工作，是指为搜集到的每一份数据都提供一个类别标签，使得该标签作为数据的一部分存在于数据集中，即标签也属于数据。如果说数据是深度学习模型的输入，那么深度学习模型的任务则是学习数据的某些特征，建立这些特征与标签之间的对应关系，训练好的深度学习模型的作用则是给没有标签的数据贴上正确的标签。显然，数据标注的首要任务是确定标签的种类和内容。根据本文的研究内容，需要将3.2节中处理好的数据按照建议并行化和不建议并行化的标准分为两类。\r\n由于串行程序能否被并行化并没有定性指标，为了统一数据标注工作的标准本文对于所有重构后的代码文件均首选使用Pluto编译器，基于Polyhedral模型进行从C/C++到OpenMp的源到源转换。对于每一份代码文件，执行如图3.8所示命令，命令相关参数含义如表3.4所示。为了更好的发现串行程序的并行性，我们允许Pluto编译器进行循环分解并且同时挖掘外层循环和内层循环的潜在并行性，此步骤的转换结果均存储在after_pluto文件目录下，具体的转换结果如图3.9所示。不难发现，Pluto编译器对于可以并行的循环片段会在合适的位置添加“#pragma omp parallel …”编译制导语句，而对于不可并行的循环片段则保持原文件不变。由于我们重构后的每段代码有且仅有一个循环片段，因此仅需对转换结果进行遍历，对于在其内容中发现“#pragma omp parallel”字样的文件，将其对应的IR文件从IR/total目录移动至IR/parallel，而对于不可并行的文件，则将其将其对应的IR文件从IR/total目录移动至IR/unparallel。如此一来，就较为方便地对大多数重构后的代码进行了快速标注。\r\n图3.8 Pluto转换命令\r\n表3.4 Pluto命令参数表\r\n参数 含义--noprevector 不进行向量化标注--tile 进行循环分解--parallel 进行并行性挖掘并转换为OpenMP--innerpar 发掘内层循环并行性\r\n图3.9 Pluto转换结果示例图\r\n与编译类似，这一过程仍然通过自动化脚本完成。由于Polyhedral模型本身存在如2.4所述限制，Pluto编译器并不能转换所有重构后的代码文件。因此在脚本执行过程中同样记录了发生转换错误的转换日志（logs/pluto_error.log）并维护一个转换错误列表error_list。脚本执行结束后，本文采用人工与其他代码分析工具结合的方式，对于转换失败的文件进行了重新标注。首先，在此类文件的循环片段上无差别的加上“#pragma omp parallel for”标记，编译执行该文件并记录其修改前后的执行时间，通过二者的差异来判断其是否具备并行潜力。然后，使用Intel® Advisor XE对上述文件进行再次分析与判断。将人工与工具两次判断的结果进行比对，对于结果相同的文件按照其具体分类进行吸收，对于结果不同的文件则予以舍弃。\r\n经过上述两个层次的标注后，重构后的代码文件及其对应的IR文件被按照是否建议使用OpenMP进行并行优化的标准分为了两个部分并分别存储在不同的文件目录中，文件目录名称即为它们所对应的标签名称，至此数据标注工作完成。\r\n3.4XFG的生成\r\n如2.3节所述，XFG是一种同时包含程序数据流信息和控制流信息的一种图结构表示，其每个节点均代表一条LLVM IR语句。在开始描述XFG的构造过程之前，需要对其中涉及到的LLVM IR语句基本结构进行说明。如图3.10所示，一条LLVM IR语句一般主要由输出变量标识符、IR指令、操作数据类型、输入变量标识符、其他参数、元数据、注释等7部分组成。其中，前5部分是LLVM IR的语义载体，是我们构造XFG的主要依据。\r\n图3.10 LLVM IR语句基本结构示例图\r\n因此，为了简化构造过程，需要先对LLVM IR文件进行如下预处理操作：（1）构造函数列表：对于每一个文件，构造一个用于存储文件中声明的所有函数名称的列表，用于XFG构造过程中标识本文件中声明的函数；（2）删除不属于IR语句的内容：LLVM编译的IR文件中，还记录了如图3.11所示IR文件的源文件名称、编译环境和编译选项等信息，此类信息与程序语义无关，不应被用来构造XFG，因此将其删除；（3）取消缩进与空行：对文件的每一行采取内容前后删除空格操作，同时删除文件中的空白行；（4）删除行尾的元数据：将每一行末尾以叹号开头的元数据移除；（5）将占用多行的单条语句合并为一行。接下来将按照如图3.12所示流程，对于IR/parallel及IR/unparallel目录下的每一个IR文件分两个阶段构造XFG。\r\n图3.11 非IR指令内容示例图\r\n图3.12 构造XFG的算法流程图\r\n第一阶段，遍历IR文件中的每一行语句，按照如下步骤构造基于标识符的XFG：\r\n（1）添加节点和边：严格按照全局变量声明、方法定义、基本块、变量赋值、存储指令、分支指令、转换指令、方法调用、返回语句、不可达代码的顺序，向图中添加节点和边。这一步骤中，会默认首先向图中添加唯一的全局根节点，基本块、变量声明等与其他标识符没有相关性的节点均为其添加一条直接与根节点相连的边。如果一行语句中出现了两个标识符，那么可以简单的认为这两个标识符节点之间存在一条边；\r\n（2）存储图结构：将步骤（1）中构建的图结构存储在临时文档中，如图3.13所示。其中，节点的信息使用其标识符进行表示，边的信息则采用形如[（node1,node2），statement]的格式分别存储其相关节点以及确定这条边的IR语句； （3）使用以下标准评估此图构造的有效性：（a）每个节点都有ID；（b）所有语句都添加到了图中；（c）没有孤立的节点；（d）节点标识符没有重复；（e）列出多重边；（f）确保为连通图；\r\n图3.13 基于标识符的XFG存储结构示例图\r\n（4）遍历图的边，在其语句中用“<%ID>”替换所有“%### xxx”形式的局部标识符，用“<@ID>”换所有“@### xxx”形式的全局标识符，用“<LABEL>”替换所有的基本块标识符。将语句中无特殊标识意义的整数、浮点数、字符串分别使用“<INT>”、“<FLOAT>”、“<STRING>”替换，将语句末尾的强类型标记（i32、i64等）使用<TYP>替换。本步骤前后的对比如图3.14所示，可以发现语句中的个性化信息被抹除，仅剩下了指令内容与操作逻辑（如对浮点型局部变量数据的加操作），对IR的表示空间进行更进一步的限制。\r\n图3.14 步骤（4）前后对比效果图\r\n（5）为边信息中的语句添加唯一标识符：在XFG中，每一条LLVM IR语句均代表一个不同的节点。但是由图3.14可知在步骤（4）之后，不同的语句间若指令内容与操作逻辑相同，则变得没有差异，因此需要在其末尾根据其出现的位置加上唯一标识以示区别（如图3.15所示）。\r\n图3.15 步骤（5）前后对比效果图\r\n第二阶段，读取第一阶段的构造成果G，对于其每一条边E，按照以下步骤继续构造基于LLVM IR语句的Dual-XFG：\r\n（1）将E涉及到的语句S1作为节点添加到Dual-XFG中。\r\n（2）在图G的所有边中找到包含边E的两个顶点其中任意一个的IR语句集合neighbor_stmt作为S1的上下文，即S1的邻节点。\r\n（3）遍历neighbor_stmt，将其中的语句添加到Dual-XFG中，并添加S1与其之间的边。\r\n（4）检查Dual-XFG是否为连通图。\r\n（5）存储Dual-XFG到相应的文件夹中（XFG/parallel或XFG/unparallel），存储格式如图3.16所示。\r\n图3.16 基于LLVM IR语句的Dual-XFG存储结构示例图\r\n至此，程序的上下文流图的构造工作全部完成，数据集GFCPD的构造也随之结束，最终数据格式如图3.17所示。其中，Dual-XFG是一个图结构的数据对象，lable是其所对应的类别标签。\r\n图3.17 GFCPD数据格式示意图\r\n3.5数据集规模\r\n由于目前的研究中，并没有专门用于挖掘串行程序并行性的图结构数据集。因此为了使深度学习模型具备更佳的表现，在GFCPD数据集的规模问题上本文一方面考虑了接下来的研究中使用的深度图卷积神经网络模型DGCNN[58]在训练过程中所使用的图数据集，如表3.5（1~8）所示；另一方面由于本研究也可以认为是一个二分类问题，考虑了一些常用的二分类问题图数据集，如表3.5（9~14）所示。\r\n表3.5 DGCNN使用的数据集信息表\r\n序号 名称 图的总数 类别 节点数均值 边的数量均值\r\n1 MUTAG 188 2 17.93 19.79\r\n2 PTC_MR 344 2 14.29 14.69\r\n3 NCI1 4110 2 29.87 32.3\r\n4 PROTEINS 1113 2 39.06 72.82\r\n5 D&D 1178 2 284.32 715.66\r\n6 IMDB-B 1000 2 19.77 96.53\r\n7 IMDB-M 1500 3 13 65.94\r\n8 COLLAB 5000 3 74.49 2457.78\r\n9 AIDS 2000 2 15.69 16.2\r\n10 BZR 405 2 35.75 38.3611 BZR_MD 306 2 21.3 225.0612 COX2 467 2 41.22 44.5413 DHFR 467 2 26.96 48.4214 KKI 83 2 77.52 198.32均值 -- 1297.21 -- 48.29 277.97最大值 -- 5000 -- 284.32 2457.78根据对表3.5中所列的14个常见图数据集的分析结果，为了使DGCNN模型可以更好地发挥其性能，本文对GFCPD数据集的规模做了如下规划：（1）图的总数不做限制；（2）节点数目平均值不大于284.32且不小于48.29；（3）边的数量均值不大于2457.78且不小于277.97。由于通过3.1~3.4节构造的原始数据集相关统计信息与上述规划相差甚远，本文对GFCPD数据集进行了进一步的裁剪，裁剪后的统计信息如表3.6所示。\r\n表3.6 GFCPD数据集信息表\r\n数据集状态 图的总数 类别数目 节点数均值 边的数量均值裁剪前 1074 2 493.72 4583.05裁剪后 850 2 130.24 539.32\r\n3.6本章小结\r\n本章根据串行程序并行性识别任务的实际需要，从图的角度出发，实现了从C/C++串行源码自动生成GFCPD数据的方法，并详细介绍了数据集GFCPD的构造过程。列举了其数据来源，描述了其数据处理方法、数据构造原则及相关算法流程，并就数据集规模的合理性问题做了一些论证。\r\n第4章基于DGCNN的串行程序并行性识别方法\r\n由1.2节可知，在程序的并行性分析问题上，出现过使用决策树、支持向量机等传统的机器学习方法进行串行程序可并行性识别的相关研究，这为使用深度学习方法实现这一目的提供了可行性参考。虽然目前还并未出现将深度学习方法应用于串行程序可并行性识别的研究成果，但代码的语义表示、不同算法的代码分类、代码缺陷检测等问题的深度学习解决方案为此提供了理论与方法的支持。综上所述，深度学习的方法在串行程序可并行性识别问题上具备着良好的可行性。本章以自动识别串行程序中可以并行的代码片段为研究目的，提出了一种基于深度图卷积神经网络（DGCNN）架构的识别方法，将深度学习方法应用于串行程序的并行性识别研究。接下来的几个小节将从数据预处理、模型建立、实验结果与分析三个方面对该方法进行详细介绍。\r\n4.1数据预处理\r\n在第3章中，考虑到数据集的通用性，为了使更多的研究可以直接使用GFCPD数据集，在其构造过程中并未对其做任何专适用于本研究的预处理工作。因此，为了更好地进行接下来的研究，需要结合本文所使用的深度图卷积神经网络模型DGCNN对实验数据进行进一步的预处理操作。在此之前，首先对DGCNN的输入数据格式进行如图4.1所示说明。对于每一个输入数据对象，graph为一个图结构的数据对象，包含了节点和边的集合，其中节点使用其编号表示，边使用节点编号的有序对表示；lable是图graph所对应的分类标签；node_tags是一个列表对象，包含了图graph所有节点对应的节点类型标签；node_features是一个列表对象，包含了图graph所有节点的特征向量。对比图3.17不难发现对于GFCPD而言，节点的类型标签和节点的特征向量是两个新的属性。显然，接下来的数据预处理工作就是为GFCPD数据集中的数据，确定并添加上述两个属性，用于做为DGCNN模型的训练数据。\r\n图4.1 DGCNN输入数据格式示意图\r\n（1）确定节点的类型标签\r\n如3.4节所述，GFCPD数据集中，XFG中的节点是一条LLVM IR语句，且在其构造过程中对IR语句进行了处理，使其仅保留了指令内容与操作逻辑。这决定了在本步骤中节点的类型标签只可以根据其指令内容或操作逻辑进行确定。\r\n考虑到仅通过人工总结并不一定能够完全覆盖所有的数据操作逻辑，同时为了限制标签数量，本文对LLVM IR的指令类型（如加、减、逻辑与、逻辑或等）进行了如表4.1所示总结，并以此作为XFG中节点的类型标签。其中0号标签表示未知指令，用于兼容特殊情况。对于0号标签以前外的其他标签，均设计了一个或多个正则匹配规则（一个指令类型可能对应多个指令，因此需要设计多个正则匹配规则，以列表的形式保存），可以通过遍历XFG的每一个节点，使用正则表达式为其匹配正确的类型标签。\r\n表4.1 节点类型标签信息表\r\n类型编号 节点类型 正则表达式\r\n0 !UNK --\r\n1 GEP <%ID> = getelementptr .*\r\n2 addition <%ID> = add .* <%ID> = fadd .*\r\n3 allocate on stack <%ID> = alloca .*\r\n… … …45 xor <%ID> = xor .*\r\n（2）确定节点的特征向量\r\n文献[34]中将XFG定义为基于LLVM IR的可学习的代码语义表示方法，并通过DeepWalk的方法对其数据集（如表4.2所示）所生成的XFG进行图嵌入训练，为XFG中的每一个节点所代表的LLVM IR语句生成了向量表示。该文通过聚类，类比，语义测试等方法验证了上述向量能够较好地表示代码语义，同时通过算法分类、异构计算平台预测等实验证明了上述向量的可学习性。\r\n由于GFCPD是一个基于XFG的图数据集，本文所使用的节点特征向量同样需要对XFG进行图嵌入训练。考虑到文献[34]的图嵌入过程所使用的数据集进行了较为全面地学科覆盖，基本包含了GFCPD原始数据中的所有程序或其类似算法，因此使用该嵌入结果作为GCFCPD数据集的节点特征向量是一个合理且不错的选择。该嵌入结果的相关信息如表4.3所示，其中共包含两个文件，一个存储的是LLVM IR语句及其编号，另一个存储的是语句编号及其对应的嵌入向量。可以通过字符串完全匹配的方法确定XFG中节点所对应的编号，从而确定其节点的特征向量。\r\n表4.2 图嵌入训练所使用的数据集信息表\r\n涉及学科 源码程序机器学习 Tensorflow高性能计算 AMD APP SDKBLAS基准测试 NAS（NPB）ParboilPolybenchGPURodiniaSHOC科学计算 COSMO操作系统 Linux kernel计算机视觉 OpenCVNVIDIA samples\r\n表4.3 图嵌入结果详细信息\r\n词典大小（IR数量） 向量维度8565 (1,200)\r\n（3）总体流程\r\n确定了节点的类型标签及其特征向量的表示方法后，就可以开始对GFCPD数据集中的数据进行进一步的改造，以适配DGCNN模型。总体流程如图4.2所示，对于每一个GFCPD数据做如下操作：首先从GFCPD数据集中读取一个Dual-XFG，获得其节点列表，即LLVM IR语句的列表；然后遍历该列表，对于每一个IR语句，通过正则匹配确定其类型标签，并将其标签所对应的编号存储在node_tag列表中，通过字符串完全匹配的方法从嵌入结果中查找IR语句对应的特征向量，存储在node_feature中；接下来对XFG中的节点编号，将节点内容使用其编号表示，将边使用节点编号的有序对表示，生成新的图graph；最后将原数据lable、graph、node_tag、node_features按照图4.1所示格式存储。\r\n4.2 基于DGCNN的串行程序并行性识别模型\r\n4.2.1 DGCNN的构建\r\nDGCNN是在文献[58]中提出的一种端到端的用于图分类的深度学习架构。与现有的图神经网络相比，它主要具有如下优势：首先它直接接受图结构的数据作为输入，而无需将图数据先转换为张量；其次，它可以通过对顶点的特征进行排序来更好的学习图的拓扑特征，而并非对顶点特征进行汇总；最后，实验证明它在许多图类型的基准数据集上相较于现有的图神经网络具有更好的性能。\r\n图4.2 数据预处理总体流程图\r\nDGCNN的总体架构如图4.3所示，其主要由三个部分组成：（1）图卷积层，输入的图数据首先通过多个图卷积层，其中每个节点的特征在其邻节点之间传播，以此来提取图中节点的局部结构特征；（2）SortPooling层，根据图卷积层的输出，按照每个节点在图结构中的不同角色及其重要程度进行排序，并统一输出为k*n的矩阵，其中k表示将使用排序后前k个节点的特征作为图的表示，n表示卷积后节点特征向量的维度；（3）传统的卷积层和全连接层，读取图的表示并进行类别预测。为了更好地理解，接下来将以本文所使用的数据为例，对其中的一些细节做出说明。\r\n图4.3 DGCNN的总体结构示意图\r\n如4.1所述，本文所使用的图数据中，节点嵌入向量的维度为1*200，节点的类型标签为46个，我们对节点的类型标签进行如图4.4所示过程的One-hot编码，并将其连接在节点的嵌入向量后，将新生成的维度为1*246的向量作为节点的特征向量进行输入。实验中共使用了四层图卷积对每一个图节点进行卷积操作，将每次卷积的结果连接起来作为其卷积后的节点特征向量，其中图卷积层的输出维度分别为32、32、32、1，那么经过卷积后每个节点的特征向量的维度均为1*97。假设一张图具有m个节点，那么经过卷积后该图的表示为一个m*97的特征矩阵，每一行代表一个节点的特征向量。\r\nSortPooling层读入上述维度为m*97的图特征矩阵，由于该矩阵每一行的最后一列是最后一层图卷积的输出，可以被认为是融合了某一个节点本身特征和类型标签的最佳表示，因此我们使用每一行的最后一列作为标准，对该矩阵的所有行进行重新排列，以此来表示图中的节点在图结构中的不同角色以及其功能。如此可以推出，如果不同图中的两个节点具备相似的角色和功能，那么在两张图的特征矩阵中，它们的相对位置相同。因此，可以认为上述排序结果决定了每个节点及其特征在图分类中的重要程度。\r\n在训练过程中，可以设定一个k值，表示使用每张图排序后的前k个节点，即特征矩阵的前k行作为图的整体表示（对于节点不足k个的图数据，将在其特征矩阵后使用0进行补齐），以进一步提取更重要的特征进行下一步的分类。\r\n图4.4 One-hot编码示例图\r\n4.2.2损失函数的确定\r\n原始DGCNN架构中，在最后阶段进行图的分类预测时采用的是softmax交叉熵损失函数（在Tensorflow中对应为softmax_cross_entropy_with_logits_v2函数），该函数是在分类问题中较为常用的的逻辑损失函数。然而该函数在处理噪声数据时（即数据标签存在错误的情况），往往会暴露出以下两大缺陷：（a）由于逻辑损失函数没有上界，错误的数据标签在损失值计算过程中导致出现了较大的异常值，对总体损失值起到了决定性作用，可能会牺牲部分正确样本，对训练结果产生不良影响；（b）由于逻辑损失函数在传递过程尾部以指数方式快速衰减，因此为了使错误标签的函数值更加接近于0，会将决策边界更接近于错误的数据标签，降低训练的准确率。针对上述两个问题，Ehsan Amid等人于2019年提出了一种双参数可调的双稳态逻辑损失函数（Bi-Tempered Logistic Loss）[59]，通过引入两个参数t1，t2分别限制损失函数的上界和其在传递过程尾部的衰减速度，将噪声数据对分类问题训练结果的影响降到了最低。其中，0<t1≦1限制了损失函数的上界，t1越小，它对损失函数上界的限制就越强；t2≧1限制了损失函数在传递过程尾部的衰减速度，t2越大，其衰减速度也就越小。\r\n考虑到串行程序中的循环片段能否并行，并没有定性的指标进行区分，虽然本文在3.3节中采用Pluto编译器对数据的分类标签进行了标准上的统一，但对于不能被Pluto编译器标注的数据仍采用了人工的方式进行标注。出于严谨考虑，本文在此假设GFCPD数据集中的数据标签存在某些随机产生的错误，为数据集引入了随机噪声，并通过分别使用两种损失函数进行实验对比，对上述假设进行了验证并确定了串行程序并行性识别模型中的损失函数，实验结果如图4.5所示。\r\n图4.5 损失函数对比实验效果图\r\n综合图4.5（a）和图4.5（b）可以发现，双稳态逻辑损失函数在训练过程中的整体表现较softmax交叉熵损失函数更加稳定。从图4.5（c）与图4.5（d）中可以看出来，双稳态逻辑损失函数在损失值的计算过程中，损失值的下降更加稳定，收敛速度较快；在训练准确率方面，双稳态逻辑损失函数也可以更好的收敛。本次实验的相关参数及所训练的模型在测试集上的准确率数据如表4.4所示，其中Sortpooling-k被选取为GFCPD数据集中所有图的节点数量均值，即每张图均使用其排序后的前131个节点的特征向量作为图的特征表示；双稳态逻辑损失函数中的参数t1,t2的确定参考了文献[59]中针对随机噪声所进行的实验参数设置，并通过多次实验进行了调整。从表4.4中的数据可知，在测试集的准确率方面双稳态逻辑损失函数仍旧占据上风。\r\n表4.4 损失函数对比试验参数及测试结果表\r\n损失函数 数据集 Sortpooling-k Num_epoch Batch_size Test-Acc（%）Softmax交叉熵损失函数 GFCPD 131 200 1 84.20双稳态逻辑损失函数（t1=0.5,t2=1.5） GFCPD 131 200 1 87.59实验表明，本文针对GFCPD数据集的数据标签中存在随机噪声的假设成立，且双稳态逻辑损失函数可以有效并显著地将噪声对分类结果的影响降低。因此，本文在串行程序并行性识别模型中，采用了双稳态逻辑损失函数并进行了一系列的对比试验。\r\n4.3实验结果与分析\r\n为了验证本文所建立的基于DGCNN的串行程序并行性识别模型在串行程序并行性识别问题上的有效性与优越性，本文将该模型与基于程序静态分析的识别方法、结合动态特征的机器学习识别方法和基于深度学习的算法分类模型分别进行了对比。在所有对比实验中，DGCNN架构的相关参数设置均如表4.5所示。\r\n表4.5 对比实验中DGCNN模型参数表\r\n参数名称 参数值图卷积层 4图卷积层输出维度 32，32，32，1学习率 0.0001Sotpooling-k 131Num_epoch 100Batch_size 1(t1,t2) (0.5,1.5)\r\n（1）对比实验一：与基于程序静态分析的识别方法对比\r\n本文在数据的标注过程中，所使用的Pluto编译器对于串行程序中的循环片段是否可以并行，采用的就是经典的静态分析策略，通过将循环片段转换为Polyheadral模型，在有限的依赖关系集合内，通过线性整数规划策略对其并行方案进行求解。\r\n在此次对比实验过程中，Pluto编译器对于GFCPD数据集的准确率数据来源于数据标注过程的统计信息，实验结果如表4.5所示。显然，在裁剪前的GFCPD数据集上，基于DGCNN的串行程序并行性识别模型的准确率明显高于基于静态分析的源到源编译器Pluto。\r\n表4.6 对比实验一实验结果表\r\n方法 数据集 准确率（%）Pluto 裁剪前的GFCPD 71.60DGCNN 裁剪前的GFCPD 86.79\r\n（2）对比实验二：与结合动态特征的机器学习识别方法对比\r\n所谓程序的动态特征主要是指在程序的运行过程中所收集到的信息，常见的程序动态特征有循环中的指令数量、循环的执行时间、关键路径长度、循环内指令间的依赖计数、外部指令对循环内指令的依赖计数以及循环内指令对外部指令的依赖计数等信息。\r\n文献[23]中使用了包括支持向量机（SVM）、决策树（Decision Tree）、增强学习算法（AdaBoost）等传统的机器学习方法对上述程序的动态特征进行了学习并实现了对串行程序并行性的预测。本文将基于DGCNN的串行程序可并行性识别模型在NPB数据集上与其实验结果进行了对比，对比结果如表4.7所示。\r\n实验结果表明，基于DGCNN架构的串行程序可并行性识别方法的准确率优于SVM和决策树。虽然相较于AdaBoost算法还有一定的差距，但是考虑到收集程序的动态信息需要运行程序，容易产生较大的时间成本和大量的数据预处理工作，本文所建立的模型在此方面仍具备一定的优越性。\r\n表4.7 对比试验二实验结果表\r\n方法 数据集 准确率（%）SVM NPB 85Decision Tree NPB 85AdaBoost NPB 92DGCNN NPB 87.20\r\n（3）对比实验三：与基于深度学习的算法分类模型对比\r\n文献[34]在验证其对于XFG节点的嵌入表示是否能够有效地代表程序语义的实验中，提出了一种基于LSTM的神经网络模型（本文称之为NCC-Model），并在对POJ-104数据集进行算法分类的实验中在达到了94.83%的准确率，略高于文献[27]中TBCNN模型在该数据集上的准确率。考虑到本文在XFG的节点特征向量的选择上，与上述实验中的代码嵌入向量相同，所以本文此次实验的对比对象为NCC-Model，其主体部分由两层LSTM和一层Batch normalization构成，详细结构如图4.6所示。\r\n图4.6 NCC-Model模型结构示意图[34]\r\n在实验过程中，将GFCPD数据集中每一个XFG所有节点的特征向量按照其节点编号的顺序逐行添加至图的特征矩阵中，并以此矩阵作为NCC-Model的输入数据，针对该模型在GFCPD数据集上的表现与DGCNN进行了对比。除此之外，本文还在上述模型的输入层之后加入了一层1-D卷积层，以此来观察通过卷积层提取特征后，该模型在GFCPD数据集上的表现。具体实验结果如表4.8所示，实验表明现有的算法分类模型并不适用于串行程序的可并行性识别任务，而基于DGCNN的识别模型可以很好的识别串行程序中的循环的并行性。\r\n表4.8 对比实验三实验结果表\r\n模型 数据集 准确率（%）NCC-Model GFCPD 67.44CNN+NCC-Model GFCPD 67.97DGCNN GFCPD 87.59综上所述，本文所提出的基于DGCNN架构的串行程序可并行性识别方法，在程序可并行性分析任务中的具备良好的可行性与有效性，相较于目前传统的静态分析方法、结合动态特征的机器学习方法以及在算法分类问题上表现良好的深度学习模型均表现出强大的竞争力。\r\n4.4本章小结\r\n本章基于深度图卷积神经网络（DGCNN）架构，提出了一种用于串行程序并行性识别的方法，并从数据预处理、模型的介绍与改进以及对比实验三个方面详细介绍了如何通过DGCNN架构将深度学习的方法应用到程序可并行性分析的研究上来。该方法直接以图数据作为输入，避免了传统程序分析过程中对于程序信息提取或运行程序所造成的时间开销与额外工作量，从另一个角度实现了串行程序的并行性识别工作。实验结果表明，该方法在多数情况下具备良好的稳定性与有效性。\r\n第5章 PML与并行编程平台\r\n如1.1所述，即使高性能计算技术正在高速发展，并行程序的开发也仍然还是一个较为复杂的任务。尤其是在医疗成像、气候模拟、药物发现、能源勘探等众多学科交叉领域，近年来出现了在大型集群系统（如：超级计算机）中同时使用两种或多种并行编程模型和框架技术来提高数据处理效率的趋势，但是相关行业软件在并行编程方面对于从业人员并不友好。下面以能源勘探行业为例，对上述领域中的行业软件存在的一些共性问题进行讨论和说明。\r\n虽然能源勘探领域的相关理论发展已经相对比较成熟，且相关研究也比较完善和透彻，但是由于计算机硬件技术和计算能力的限制，相当多的优秀理论仍尚未投入实际的工程应用。近几年来，随着计算机硬件及相关技术的飞速发展，计算能力得到了显著提高，越来越多的能源勘探领域从业人员开始使用MPI、OpenMP、CUDA等并行编程技术来提高工作效率与质量。综合对比该行业内较为流行的三种现有的能源勘探软件系统，其中Seismic Unix和Madagascar主要用于科学研究的开源软件系统，而GeoEast则是由由中国石油集团自主研发的商业能源勘探软件。从表5.1所示内容可以发现，在功能上三者尽可能多的包含了能源勘探整体流程所需要的算法以及功能；在技术上都支持系统的分布式部署和数据的并行管理；而且GeoEast还具备任务的并行调度管理和一些其他特性。但是三者无一例外地都忽略了在用户自主扩展编程过程中的并行编程问题以及单个处理流程内部的线程级并行优化问题。用户需要使用普通的IDE在没有任何并行编程指导的情况下去手工编写实现自己的数据处理功能。显然，由于各种并行编程模型和框架之间缺少一个简单易懂，方便易用的统一编程规范接口，彼此在使用方法、系统环境要求等诸多方面的标准并不统一，对上述领域的从业人员在并行编程方面造成了较大阻碍，参差不齐的贡献者水平也使得相关开源软件可扩展性受损、发展受阻。\r\n表5.1 能源勘探行业软件对比信息表\r\n对比项 Seismic Unix Madagascar GeoEast算法覆盖 √ √ √数据处理 √ √ √分布式部署 √ √ √任务并行调度 * * √流程内并行策略 * * *扩展编程方式 本地IDE 本地IDE 本地IDE并行编程指导 * * *应用形式 命令行工具 命令行工具 Web应用为了解决这一问题，国家重点研发计划“面向E级计算的能源勘探高性能应用软件系统与示范”在其课题一（任务3：“面向E级计算的能源勘探应用软件并行化策略”）中，明确提出了要研究一种适合能源勘探领域通用的并行化标记语言和代码生成工具，建立标记语言与并行混合编程模型之间的映射，实现能源勘探程序到E级计算平台上并行程序的自动生成。\r\n5.1基于XML的并行标记语言\r\n在计算机文本处理过程中，标记语言是一种使用有限且通用的标记将文本内容和其他相关信息结合起来的技术手段。HTML和XML是当前常见的描述性标记语言，二者均属于标准通用标记语言（Standard GeneraiizesMarkup Language，SGML）。其中，HTML具有提前设定的语义和简单精炼的语法，这意味着它在保证通用性和易用性的前提下同时规定了如何在特定媒体上呈现结构化数据，因此HTML被广泛的应用在网页的创建和互联网信息的描述中。XML借鉴了HTML成功的经验，将HTML的高效易用与SGML的丰富功能相结合，多被用于定义数据本身的结构、数据类型及相关数据操作。XML因其显著的技术优势（将在5.1.1小节进行详细介绍）具有着更加广泛的应用和更加广阔的前景。本节内容中，并行标记语言PML被设计用来统一并行编程接口，对串行程序可以并行的部分及具体并行优化操作进行标识和描述，接下来的几个小节将详细介绍并行标记语言PML从构思到实现的具体细节。\r\n5.1.1可行性分析\r\n（1）并行编程模型是一种类XML的标记语言\r\n一般地，目前较为常用的程序并行化途径大致可以分为以下4种：（a）采用消息传递模型MPI，通过在串行程序中调用MPI库函数（多为MPI_XXX（）的形式），完成数据在线程间、节点间的交互通信，提高执行效率。（b）使用共享内存模型OpenMP，通过在串行程序中插入编译制导语句（多为#omp parallel XXX的形式），以注释的形式告知计算机如何将代码编译为可并行执行的程序。（c）采用CUDA编程，同时利用CPU和图形处理器（GPU），调用CUDA核函数，将原串行程序改造为CUDA程序，加快应用程序的运行速度。（d）混合编程模型，即同时采用上述三种途径中的两种或多种。本质上，上述途径（a）、（b）、（c）均可以看作是对现有编程语言（如：C、Fortran等），通过添加库函数、插入编译制导语句等手段进行的扩展。而向串行程序中添加的库函数调用及编译制导语句，完全可以看作是对串行程序中可并行执行部分的一种标识，是对如何进行并行优化的一种描述。这与可扩展标记语言XML的用途类似，因此从本质上我们也可以认为MPI、OpenMP等并行编程模型是一种并行标记语言，只不过他们对标记的形式、使用方法的定义各有不同。\r\n（2）XML技术优势显著\r\n在设计并行标记语言方面，XML主要存在如下几个方面的技术优势：（a）它具备良好的可读性。人们可以在XML文档中对相关语义定义唯一且固定的标记。（b）它具备强大的可扩展性。XML允许用户自定义标记集合以满足他们的具体需要，并无障碍地将这些标记集合投入到实际使用中。（c）它便于信息的检索。XML通过在文档中插入特定的标记表示相应的含义，所以可以简单而高效地根据标记对整个文档进行搜索。这样一来，如果用户想要在超大规模的代码文件中搜索所有的并行标记便不再困难。（d）它支持不同文字不同符号间的信息交互。由于XML使用Unicode标准，可以有效地支持所有编程语言中所使用的各种符号以及世界各地的语言文字，甚至可以将并行标记语言的标签设计为中文。（e）具备与代码类似地层级结构。在编程语言中，一份代码包含着若干个函数，一个函数中包含了若干个结构（分支、循环等），一个结构中又包含了若干语句。类似地，XML文档在逻辑上是一种树状结构，文档中的每一个元素均以节点的形式按照层次关系进行了合理地组织。\r\n（3）存在基于XML实现标记语言的相关研究\r\n实际上，现在许多领域都在使用XML设计和实现其业内通用的标记语言。比较典型的有：化学标记语言CML、矢量图形标记语言VML以及无线通信标记语言WML等。此外，表5.2还列出了一些近年来XML被用于设计其他专用标记语言的相关研究。\r\n表5.2 基于XML的标记语言相关研究信息表\r\n序号 研究内容\r\n1 基于XML的Agent通信语言[60]\r\n2 基于XML的STEP-NC程序解释器[61]\r\n3 基于XML的仿真想定标记语言SSML[62]\r\n4 基于XML的软PLC语言编辑系统[63]\r\n5 基于XML的消息队列标记语言[64]\r\n6 基于XML的虚拟仪器标记语言—VIML[65]\r\n7 基于XML的机械图形标记语言的研究与开发[66]\r\n综上所述，XML显然是定义新的标记语言的一个不错的选择，基于XML技术来实现并行标记语言PML是完全可行的。\r\n5.1.2 PML的设计与实现\r\n（1）技术路线\r\nPML旨在提出一种适合科学计算相关领域使用的并行编程标记语言和代码生成工具，建立PML标签与经典并行混合编程模型（MPI+OpenMP）之间统一的映射接口，实现串行程序到并行程序的源到源转换。\r\n本文将XML作为实现并行标记语言PML的基础技术路线（如图5.1所示），首先通过大量参考编写良好的MPI+OpenMP混合编程模型代码，总结归纳其常用函数、指令以及格式并进行抽象概括，以达到设计尽量少的PML标签进行尽量多的功能覆盖的目的。然后定义XSLT文件，描述所设计的PML标签与并行编程模型之间的对应关系及具体的转换规则，为从串行代码到并行代码的转换提供转换模板。最后开发转换程序，按照XSLT文件实现从加入了PML标签的串行代码自动转换为并行代码的功能。\r\n图5.1 并行标记语言技术路线图\r\n（2）标签详情\r\n为了方便使用和理解，统一不同并行编程模型和框架的编程接口，本文将PML语言的标签全部设计为格式统一的中文标签。PML标签共计70个，其中PML根节点标签1个，MPI相关标签36个，包括5个初等例程、8个点对点消息传递例程、6个组通信例程以及17个常用的参数标签；OpenMP相关标签33个，包括13个常用指令、8个常用API库函数以及12个常用子句。在PML的所有标签中，参数标签统一设置，不存在各个例程中含义相同的参数标签不统一的情况，且<返回值>标签在不需要使用其返回值时均可以缺省，当需要返回值时，仅需将返回值接收变量写在该标签内即可。以MPI为例，其初始化与终止例程的简单C语言代码示例与对应的PML程序示例如图5.2所示，可以发现，PML语言所写的程序源码文件为XML文档（后缀名为。xml），且PML并不改变原有的C语言编程语法规范与编程逻辑，仅仅只是在本应调用并行编程模型的位置，将不同的调用语句替换为了标准统一的PML标签。\r\n图5.2 C语言与PML程序示例图\r\n（3）转换机制\r\n由上文所述技术路线可知，PML标签向普通C/C++语言代码转换的功能主要由XSLT文件负责，XSLT文件本身也是一种XML格式的文档，可以看作是普通XML文档的样式表（类似CSS之于HTML），用于定义XML标签的转换逻辑，这些逻辑会应用于XML文档树状结构的节点集上，然后生成HTML、文本或其他形式的输出文件。\r\n在PML语言的XSLT文件中，将输出类型定义为文本类型，并且为每一个设计好的PML标签都定义了转换规则。每个转换规则一般都与XPATH关联，XPATH代表着标签在XML文档的树状结构中的层次信息，表明了这个规则适用于哪一个或哪一类节点，用于定位标签在XML文档中的位置从而查找匹配正确的标签进行转换。当然，这种规则也被称做模板（Template），在XSLT中使用标签<xsl:template>表示，并使用该标签的match属性来关联XPATH表达式。仍以图5.2所示PML程序为例，其中所使用到的MPI环境终止标签的XSLT转换规则如图5.3所示，此规则仅作用于<MPI终止>标签，并且XPATH规定这个<MPI终止>标签必须是根节点的直接子节点，才能使用这个规则。值得注意的是，XSLT文档还提供了条件判断、选择分支等功能。在图5.3中，<xsl:choose>标签用于结合 <xsl:when> 和 <xsl:otherwise> 来表达条件分支。在该规则中，如果<返回值>标签存在且不为空（假设为ret），则对应的将标签转换为“ret=MPI_Finalize（）；”，否则直接转换为“MPI_Finalize（）；”。\r\n图5.3 XSLT示例图\r\n图5.2中的PML程序向并行化的C语言程序转换的完整流程如图5.4所示。对于根节点标签<PML>下的文本内容，直接将其保留；而对于其他PML标签包裹的内容则通过match属性匹配XSLT模板中定义的转换规则进行转换。为了实现这一流程的自动化，本文开发了一个专门用于PML代码向C语言代码转换的转换程序，算法描述如图5.5所示。其中为了适应接下来的章节中所提及到的部分功能，算法中所使用的PML代码由浏览器端http请求传回，对PML代码中的部分内容进行了一些预处理工作以避免一些字符编码问题。\r\n图5.4 PML向C/C++语言转换示例图\r\n图5.5 PML转换算法描述图\r\n5.2并行编程辅助平台\r\n考虑到PML的设计是为了更好的进行并行程序编程开发，目前主流的XML文档编辑器虽然功能完善且使用方便，但是很难为C/C++语言提供诸如着色、格式化等特性功能，同时为了使本文的所有研究成果更好的统一与融合，本着部署方便、使用简单和易于扩展的原则，本文结合Web开发相关技术与部分开源项目搭建了一个基于MVC（Model – View – Controller）三层架构模式的并行编程辅助平台。为用户提供串行程序开发功能、串行程序的并行性自动识别功能、PML并行标记语言开发功能、并行程序自动转换功能和远程集群系统调试功能。\r\n平台的详细架构如图5.6所示，模型层负责数据的建模与访问，将PML标签存储在MySQL数据库中；视图层负责和用户交互，为用户提供串行程序的并行性识别、PML使用指导、程序编辑、程序调试等具体的功能体验；控制层则负责视图层各种功能体验的逻辑实现，处理用户发来的请求并作出正确响应。在使用过程中，用户通过浏览器访问本平台，在编辑器中进行C/C++串行程序的开发，通过使用串行程序的并行性识别功能自动识别出串行程序中可以并行的部分，然后使用PML标签对可以并行的部分进行并行化开发，将开发好的PML程序提交到服务器自动转换为并行程序，最后通过SSH终端在浏览器中实现程序在远程集群环境上的调试。\r\n为了更好地说明本文所有研究成果的融合过程，本章接下来的内容将首先按照MVC三层架构的顺序，依次介绍并行编程辅助平台各个基础功能的实现技术，然后再单独介绍如何将串行程序的并行性识别功能集成到平台上来。\r\n图5.6 并行编程辅助平台架构图\r\n5.2.1基础功能的实现\r\n（1）模型层\r\n模型层的主要功能是为数据相关的操作提供支持服务，保证数据的一致性与稳定性。在本平台的生命周期中，数据主要指的是PML语言的编程标签。由于在本研究中PML标签被定义为统一的标准编程接口，因此数据相关的操作主要为读取操作。\r\n本平台在模型层采用了较为流行的关系型数据库MySQL。在数据库存储结构的设计中，考虑到需要在视图层为用户提供PML使用指导及PML标签的插入等交互功能，对编程模型的分类、标签的功能分类、标签的基础信息以及标签的使用引导等方面均设计了相应的表或字段。详细的设计信息如表5.3、表5.4、表5.5所示。同时，为了保证平台运行过程中数据的一致性与稳定性，本平台严格按照数据库表的结构封装了相应的Java实体类，将表中的字段设计为私有的类属性，并通过为每一个属性提供get和set方法来控制对私有属性的访问和修改行为，从根本上避免数据的一致性问题和安全性问题。\r\n表5.3 数据库标签表结构\r\n表名 字段 描述pml_tag Id 标签编号Model_type 并行编程模型类别，外键Tag 标签内容Code C语言代码Desc 标签功能描述Param 参数详解Tag_type 标签功能类型，外键\r\n表5.4 数据库标签类别表结构\r\n表名 字段 描述tag_type Type_name PML标签类别名称Type_id 类别编号，用于外键\r\n表5.5 数据库并行编程模型表结构\r\n表名 字段 描述model_type Type_name 模型名称Type_id 类别编号，用于外键\r\n（2）视图层\r\n视图层的主要作用，是为用户提供全面的功能服务和良好的交互体验，考虑到用户访问本平台的本地环境和浏览器不尽相同，为了平台更好的兼容性和可扩展性，视图层主要基于开源软件技术进行构建。在网页布局上采用BootStrap框架，使用其自带的全局CSS设置和网格系统，再结合HTML5+CSS3+JavaScript技术实现页面美化。在PML编辑功能部分，参考了当前较为流行的在线编辑器（如Cloud9等）的技术路线，采用基于JavaScript的富文本编辑器Ace Editor实现了PML代码编辑，通过修改或重写其Js脚本实现了PML+C/C++混合编程代码的着色及高亮显示、代码格式化、用户个性化设置等基础功能。\r\n视图层的实现效果如图5.7所示，其主要由两部分构成。红色框内的部分为标签列表，该部分将数据库中的PML标签按照并行编程模型的类型进行分类，然后再按照标签的功能类型进行罗列。对于每一个PML标签，均为其提供详情和插入两个选项，分别通过列表上的两个按钮实现。用户可以点击详情按钮，通过如图5.8所示页面查看该PML标签的详细信息，其中包括该标签的PML代码、C语言代码、功能简介以及参数含义；用户还可以点击插入按钮，直接将该标签对应的PML代码插入至编辑器中光标所在位置。编辑器指的是图中由蓝色框圈出的部分，该部分为用户提供了普通的C/C++代码编辑、PML语言编辑以及对应的代码高亮着色、格式化和个性化设置等功能。此外，编辑器部分在后续的介绍中，还将通过绿色框内的选项按钮被赋予更多的功能角色。\r\n图5.7 平台视图层效果图\r\n图5.8 标签详情页面效果图\r\n（3）控制层\r\n控制层的主要功能可以分为web服务器功能、代码转换功能、SSH跳转机功能、数据库操作功能和串行程序的并行性识别功能，是整个平台的逻辑核心。它可以在保证平台被用户正常访问的前提下，稳定持续地帮助用户识别串行代码中可以并行的部分，并为用户提供PML代码向C/C++代码的转换服务，方便用户通过SSH协议连接远程集群系统进行代码调试。其中，各项功能的相关实现技术如表5.6所示。需要注意的是，GateOne是一个开源的基于HTML的Web Terminal SSH客户端，除了使用正常的HTML标签将其嵌入在我们的Web应用中之外，GateOne终端的使用还需要在本地服务器的应用脚本和远程服务器的配置文件上进行双重个性化配置才可以正常使用，相关配置文件如图5.9所示。\r\n表5.6 控制层相关实现技术信息表\r\n功能 技术web服务器功能 Apache Tomcat7.0SSH跳转机功能 GateOne数据库操作功能 JDBC代码转换功能 XSLT+转换程序串行代码的并行性识别功能 DGCNN识别模型\r\n图5.9 GateOne配置示例图\r\n以计算PI的程序为例，用户通过浏览器访问本平台，在编辑器中开发串行版本的C语言程序，通过并行性识别功能对代码中可以并行的部分进行识别，然后通过PML标签对程序进行并行化开发，点击转换选项得到如图5.10所示转换结果。为了验证转换后的并行程序是否正确，用户可以点击终端选项，在网页中开启SSH终端，将该代码上传至远程服务器进行调试，调试结果如图5.11所示。\r\n图5.10 代码转换效果图\r\n图5.11 SSH终端远程调试效果图\r\n5.2.2串行代码的并行性识别功能的集成\r\n为了使本文的研究成果更好的融合与统一，使并行编程辅助平台的使用流程更加完善，本小节对本文第4章中串行程序的并行性识别功能进行了集成，整体流程如图5.12所示。接下来将分为数据提取、数据预处理和并行性识别三个阶段进行详细介绍。\r\n在数据提取阶段，对于用户提交的需要进行并行性识别的串行代码，仍沿用3.2节所介绍的GFCPD数据构造方式，首先按顺序提取程序中的所有循环片段并进行编号，在源码文件中以注释的形式使用循环片段的编号替换其本身；然后对于每一个循环片段均进行代码重构，同时使用该循环片段的编号对重构后的代码文件进行命名，重构结果如图5.13所示；最后对重构后的代码文件逐一构造XFG。需要注意的是，图5.13可以看出，本过程中虽然在提取循环片段时需要提取所有函数的相关信息，但是并没有将函数的完整定义使用其声明在源码文件中进行替换，这是为了便于在最后阶段将并行性识别的结果反馈在视图层中的同时，不改变代码的本身结构和内容。\r\n在数据预处理阶段，对于上述阶段的中间结果XFG_list采用如4.1节所述的预处理方式，按顺序对XFG进行嵌入表示生成data_list以作为下一阶段的输入。必须说明的是，此处的顺序代表了循环片段在源码文件中的相对顺序，为了使并行性识别的结果正确的反馈给视图层，该顺序不可进行改变。\r\n在并行性识别阶段，平台通过后台程序，调用使用GFCPD数据集训练好的DGCNN模型，对数据预处理阶段生成的所有数据进行预测。预测结果是一个与循环提取过程中循环片段的编号顺序相同的结果列表result_list。仍以图5.13所示的源码文件为例，假设其预测结果如图5.14（a）所示，此结果说明源码文件中存在着两个循环片段，且第一个循环片段可以并行化，而第二个循环片段不可以并行化。此时，平台后台程序会将第一个循环片段按照如图5.14（b）所示形式进行标注，然后在源码文件中使用该形式替换循环片段所对应的注释内容“//loop1”；而对于第二个循环片段则不做任何标注，直接还原至源码文件中。最后后台程序将如图5.14（c）所示结果反馈给视图层展示在编辑器中，用户可根据识别结果做进一步并行化改造。\r\n图5.12 串行代码的并行性识别功能集成流程图\r\n图5.13 数据提取阶段提取结果示例图\r\n图5.14 串行程序并行性识别结果示例图\r\n5.3本章小结\r\n本章中提出并实现了一种基于XML的并行标记语言PML，消除了各个编程模型和框架之间的标准壁垒，为用户提供了统一的标准编程接口，大大降低了并行程序开发的技术门槛，同时基于Web开发相关技术，提供了轻量级的在线编程平台，在满足正常代码编辑需求的前提下，集成了基于深度学习的串行代码并行性识别功能，为用户的并行编程提供技术指导。\r\n结论\r\n随着社会和科技的发展，计算机硬件和架构设计理念的转变使得多核系统越来越受欢迎，多核技术为计算机的性能带来了巨大的潜在提升。为了充分开发和利用这一潜力，高性能计算领域进入了新的发展时期，并行编程技术的相关研究也活跃了起来，并行化成为了新的发展趋势。并行编程在诸如医疗成像、气候模拟、药物发现、地质能源勘探等众多领域的实际工程应用中占据着越来越重要的位置。然而，并行程序开发并不是一项简单的工作，虽然目前并行编程方法和程序并行性分析工具的发展势头良好，但对于上述领域的从业人员来讲熟练且高效地进行并行程序开发仍存在着较大的难度。主要体现在两个方面：一方面，由于需要对程序的数学表示进行限制或收集程序的运行时特征，目前的程序并行性分析与优化工具存在着较大的局限性，这些局限性使得其对于上述领域中普遍存在的程序复杂、数据量大且执行时间长的应用程序并不友好；另一方面，目前广泛使用的并行编程模型（如MPI、OpenMP等）所采用的编程方法和手段并不统一，但实际工程中往往需要结合其中的两种或多种，多个不同标准的学习和交叉使用为此增加了一定难度。\r\n针对上述两个方面，本文研究了一种基于深度学习的串行程序并行化方法，为开发人员从程序的并行性识别，到统一并行编程模型接口，再到并行程序的开发与调试提供了整套的解决方案。本文的主要工作如下：\r\n（1）以程序的上下文流图（XFG）为数据格式，构造了一个可以用于串行程序的并行性识别的深度学习图数据集GFCPD，设计并开发了包括数据提取、代码重构、编译检验、数据标注以及XFG生成等流程在内的用于生成GFCPD数据集数据的自动化脚本。\r\n（2）构建了基于图卷积神经网络的串行程序并行性识别模型。通过该模型针对GFCPD数据集进行学习，使用深度学习的方法实现了串行程序的并行性识别。实验表明，本文所建立的模型在串行程序的并行性识别任务中，存在着良好的可行性与有效性。相较于目前传统的静态分析方法、结合动态特征的机器学习方法以及在算法分类问题上表现良好的深度学习模型均表现出强大的竞争力。\r\n（3）基于XML技术设计并实现了并行标记语言PML。为目前较为流行的两种并行编程模型（MPI与OpenMP）设计了格式统一、使用方便的中文标签，并实现了从XML标签到C/C++代码的转换程序，提供了更加简易快捷的并行编程途径。\r\n（4）搭建了并行编程辅助平台，将串行程序的并行性预测、并行标记语言PML两大功能集成在该平台上，同时通过GateOne SSH终端技术将远程调试变为了可能。用户可以在辅助平台中按照正常的C/C++编程语法规范在编辑器内编写串行程序，平台通过并行性识别模型对用户的程序进行并行性识别并在可以并行的循环片段前后加以注释提醒；然后用户可以通过列表查看PML标签说明，通过手动编写或点击按钮的方式直接向编辑器内的指定位置插入PML标签；最后用户将PML程序提交至后台进行转换，同时使用SSH终端连接其远程服务器，将转换后的C/C++代码上传至远程服务器进行调试。\r\n虽然本文在完成研究的整个过程中，取得了一定的阶段性成果，完成了最初设定的目标，但是本研究仍然存在着一些问题以及一些新的研究方向，需要进一步的解决和探索，主要有以下几方面：\r\n（1）本文在构造GFCPD数据集的过程中，由于搜集的原始数据有限，且部分源码文件因其不可编译或无法确定并行性而被舍弃，导致了GFCPD数据集规模的小幅度缩减，如果对GFCPD数据集进行进一步的扩充与完善可能会使本研究的研究成果更加出色。\r\n（2）程序可以使用数据流图、控制流图、函数调用图等多种图表示形式分别表示不同方面的语义信息。因本文在研究中所使用的深度图卷积神经网络模型仅接收一个图对象作为输入进行训练和预测，所以本文选取了在设计上结合了数据流图和控制流图的图表示形式XFG，但XFG并不能被认为全面完整地表示了程序的语义信息。如何使用接收多图作为输入的图神经网络模型，更完整的利用程序的语义信息进行并行性分析，是下一步研究的重要内容。\r\n（3）PML编程语言目前仅支持MPI和OpenMP两种并行编程模型，下一步的研究可以向其中添加CUDA等其他编程模型的支持，并在辅助平台上为用户提供定制功能，允许用户将自己常用的编程结构或标签组合定制为新的自定义标签。\r\n参考文献\r\nKirk D B, Wen-Mei W H. Programming massively parallel processors: a hands-on approach[M]. Morgan kaufmann, 2016.\r\nHwu W, Keutzer K, Mattson T G. The concurrency challenge[J]. IEEE Design & Test of Computers, 2008, 25(4): 312-320.\r\nH. Sutter. Welcome to the Jungle.http://herbsutter.com/welcome-to-the-jungle/, 2012. [Last access 4th April 2020].\r\nSanchez L M, Fernandez J, Sotomayor R, et al. A comparative study and evaluation of parallel programming models for shared-memory parallel architectures[J]. New Generation Computing, 2013, 31(3): 139-161.\r\nMcCool M, Reinders J, Robison A. Structured parallel programming: patterns for efficient computation[M]. Elsevier, 2012.\r\nSun X, Liu X, Hu J, et al. Empirical studies on the nlp techniques for source code data preprocessing[C]//Proceedings of the 2014 3rd International Workshop on Evidential Assessment of Software Technologies. 2014:32-39.\r\n乐晓波, 汪琳, 黄敏. 用 Petri 网分析循环程序的并行性[D]., 2002.\r\n蒋作, 高毅. 关于串行程序并行化[J]. 云南民族大学学报 (自然科学版), 2007, 16(3): 274-276.\r\n梁博, 安虹 [1, 王莉, 等. 针对子程序结构的线程级推测并行性分析[D]. , 2009.\r\n闫昭. 程序并行识别方法及应用研究[D]. 长春: 吉林大学, 2009.\r\n郭慎, 李培峰, 朱巧明. 一种基于特征的程序可并行点发现方法[J]. 计算机应用与软件, 2011, 28(4): 24-26.\r\n王磊, 曲卫平, 李敬兆. 基于人工智能搜索和数据依赖分析的程序并行化[J]现代电子技术, 2013, 36(6): 1-3.\r\n王家龙, 刘艳红, 沈立. 线程级猜测并行系统代码自动生成工具的设计与实现[J]. 计算机科学, 2017, 44(11): 114-119.\r\n王时雨, 张盛兵, 安建峰, 等. 基于 LLVM 架构的图像处理程序的并行分类[J]. 微电子学与计算机, 2018, 35(1): 66-71.\r\n谭丁武,张坤芳,刘燕,郑一基,鲁鸣鸣.基于门控图注意力神经网络的程序分类[J].计算机工程与应用,2020,56(07):176-183.\r\nBondhugula U, Hartono A, Ramanujam J, et al. A practical automatic polyhedral parallelizer and locality optimizer[C]//Proceedings of the 29th ACM SIGPLAN Conference on Programming Language Design and Implementation. 2008: 101-113.\r\nBaghdadi R, Ray J, Romdhane M B, et al. Tiramisu: A polyhedral compiler for expressing fast and portable code[C]//2019 IEEE/ACM International Symposium on Code Generation and Optimization (CGO). IEEE, 2019: 193-205.\r\nPalkowski M, Bielecki W. Tuning iteration space slicing based tiled multi-core code implementing Nussinov’s RNA folding[J]. BMC bioinformatics, 2018, 19(1): 12.\r\nPalkowski M, Bielecki W. Parallel Tiled Codes Implementing the Smith–Waterman Alignment Algorithm for Two and Three Sequences[J]. Journal of Computational Biology, 2018, 25(10): 1106-1119.\r\nPalkowski M, Bielecki W. Tiling Nussinov’s RNA folding loop nest with a space-time approach[J]. BMC bioinformatics, 2019, 20(1): 208.\r\nDiaz J, Munoz-Caro C, Nino A. A survey of parallel programming models and tools in the multi and many-core era[J]. IEEE Transactions on parallel and distributed systems, 2012, 23(8): 1369-1386.\r\nFried D, Li Z, Jannesari A, et al. Predicting parallelization of sequential programs using supervised learning[C]//2013 12th International Conference on Machine Learning and Applications. IEEE, 2013, 2: 72-77.\r\nLi Z. Discovery of potential parallelism in sequential programs[D]. Technische Universität Darmstadt, 2016.\r\ndel Rio Astorga D, Dolz M F, Sanchez L M, et al. Discovering pipeline parallel patterns in sequential legacy C++ codes[C]//Proceedings of the 7th International Workshop on Programming Models and Applications for Multicores and Manycores. 2016: 11-19.\r\ndel Rio Astorga D, Dolz M F, Sánchez L M, et al. Finding parallel patterns through static analysis in C++ applications[J]. The International Journal of High Performance Computing Applications, 2018, 32(6): 779-788.\r\nZhao H, Zheng F, Wu J, et al. Automatic Parallelization for Binary on Multi-core Platforms[C]//Proceedings of the 2nd International Conference on Computer Science and Application Engineering. 2018: 1-6.\r\nMou L, Li G, Zhang L, et al. Convolutional neural networks over tree structures for programming language processing[C]//Thirtieth AAAI Conference on Artificial Intelligence. 2016.\r\nHellendoorn V J, Devanbu P. Are deep neural networks the best choice for modeling source code?[C]//Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering. 2017: 763-773.\r\nChoi M, Jeong S, Oh H, et al. End-to-end prediction of buffer overruns from raw source code via neural memory networks[J]. arXiv preprint arXiv:1703.02458, 2017.\r\nSestili C D, Snavely W S, VanHoudnos N M. Towards security defect prediction with AI[J]. arXiv preprint arXiv:1808.09897, 2018.\r\nAlon U, Zilberstein M, Levy O, et al. A general path-based representation for predicting program properties[J]. ACM SIGPLAN Notices, 2018, 53(4): 404-419.\r\nAlon U, Zilberstein M, Levy O, et al. code2vec: Learning distributed representations of code[J]. Proceedings of the ACM on Programming Languages, 2019, 3(POPL): 1-29.\r\nAllamanis M, Brockschmidt M, Khademi M. Learning to represent programs with graphs[J]. arXiv preprint arXiv:1711.00740, 2017.\r\nBen-Nun T, Jakobovits A S, Hoefler T. Neural code comprehension: A learnable representation of code semantics[C]//Advances in Neural Information Processing Systems. 2018: 3585-3597.\r\nChen Z, Monperrus M. A literature study of embeddings on source code[J]. arXiv preprint arXiv:1904.03061, 2019.\r\n王克朝, 成坚, 王甜甜, 等. 面向程序分析的插桩技术研究[J]. 计算机应用研究, 2015, 32(2): 479-484.\r\nHarrold M J, Larsen L, Lloyd J, et al. Aristotle: A system for development of program analysis based tools[C]//Proceedings of the 33rd annual on Southeast regional conference. 1995: 110-119.\r\nKirchner F, Kosmatov N, Prevosto V, et al. Frama-C: A software analysis perspective[J]. Formal Aspects of Computing, 2015, 27(3): 573-609.\r\nGarcia S, Jeon D, Louie C M, et al. Kremlin: rethinking and rebooting gprof for the multicore age[J]. ACM SIGPLAN Notices, 2011, 46(6): 458-469.\r\nZhang X, Navabi A, Jagannathan S. Alchemist: A transparent dependence distance profiling infrastructure[C]//2009 International Symposium on Code Generation and Optimization. IEEE, 2009: 47-58.\r\nKetterlin A, Clauss P. Profiling data-dependence to assist parallelization: Framework, scope, and optimization[C]//2012 45th Annual IEEE/ACM International Symposium on Microarchitecture. IEEE, 2012: 437-448.\r\nSubotic V, Ayguadé E, Labarta J, et al. Automatic exploration of potential parallelism in sequential applications[C]//International Supercomputing Conference. Springer, Cham, 2014: 156-171.\r\nBlair-Chappell S, Stokes A. Parallel programming with intel parallel studio XE[M]. John Wiley & Sons, 2012.\r\nSilexica GmbH. https://www.silexica.com. [Last access 4th April 2020].\r\nBischof C, Huss-Lederman S, Sun X, et al. The PRISM project: Infrastructure and algorithms for parallel eigensolvers[C]//Proceedings of Scalable Parallel Libraries Conference. IEEE, 1993: 123-131.\r\nGrosser T, Groesslinger A, Lengauer C. Polly—performing polyhedral optimizations on a low-level intermediate representation[J]. Parallel Processing Letters, 2012, 22(04): 1250010.\r\nRauchwerger L, Padua D A. The LRPD test: Speculative run-time parallelization of loops with privatization and reduction parallelization[J]. IEEE Transactions on Parallel and Distributed Systems, 1999, 10(2): 160-180.\r\nJimborean A, Clauss P, Dollinger J F, et al. Dynamic and speculative polyhedral parallelization using compiler-generated skeletons[J]. International Journal of Parallel Programming, 2014, 42(4): 529-545.\r\nGómez-Sousa H, Arenaz M, Rubiños-López Ó, et al. Novel source-to-source compiler approach for the automatic parallelization of codes based on the method of moments[C]//2015 9th European Conference on Antennas and Propagation (EuCAP). IEEE, 2015: 1-6.\r\nAmini M, Creusillet B, Even S, et al. Par4all: From convex array regions to heterogeneous computing[C]. 2012.\r\nBondhugula U, Baskaran M, Krishnamoorthy S, et al. Automatic transformations for communication-minimized parallelization and locality optimization in the polyhedral model[C]//International Conference on Compiler Construction. Springer, Berlin, Heidelberg, 2008: 132-146.\r\nLee S I, Johnson T A, Eigenmann R. Cetus–an extensible compiler infrastructure for source-to-source transformation[C]//International Workshop on Languages and Compilers for Parallel Computing. Springer, Berlin, Heidelberg, 2003: 539-553.\r\nLattner C, Adve V. LLVM: A compilation framework for lifelong program analysis & transformation[C]//International Symposium on Code Generation and Optimization, 2004. CGO 2004. IEEE, 2004: 75-86.\r\n赵捷, 李颖颖, 赵荣彩. 基于多面体模型的编译 “黑魔法”[J]. 软件学报, 2018 (8): 15.\r\nWu Z, Pan S, Chen F, et al. A comprehensive survey on graph neural networks[J]. IEEE Transactions on Neural Networks and Learning Systems, 2020.\r\nGori M, Monfardini G, Scarselli F. A new model for learning in graph domains[C]//Proceedings. 2005 IEEE International Joint Conference on Neural Networks, 2005. IEEE, 2005, 2: 729-734.\r\nKipf T N, Welling M. Semi-supervised classification with graph convolutional networks[J]. arXiv preprint arXiv:1609.02907, 2016.\r\nZhang M, Cui Z, Neumann M, et al. An end-to-end deep learning architecture for graph classification[C]//Thirty-Second AAAI Conference on Artificial Intelligence. 2018.\r\nAmid E, Warmuth M K K, Anil R, et al. Robust Bi-Tempered Logistic Loss Based on Bregman Divergences[C]//Advances in Neural Information Processing Systems. 2019: 14987-14996.\r\n凌兴宏. 基于XML的Agent通信语言[J]. 计算机应用研究, 2003, 20(7):152-154.\r\n于东, 李筱颿, 黄艳, et al. 基于XML的STEP-NC程序解释器的设计与实现[J]. 小型微型计算机系统, 2009, 30(10):1956-1959.\r\n陈欣, 胡晓惠, 付勇, et al. 基于XML的仿真想定标记语言SSML[J]. 系统仿真学报, 2004, 16(9):1928-1930.\r\n吴倩, 陶亦亦, 陆春元. 基于XML的软PLC语言编辑系统的设计与实现[J]. 机械制造与自动化, 2007, 36(2):100-102.\r\n陈林, 黄晔. 基于XML的消息队列标记语言[J]. 计算机工程, 2007, 33(19):85-87.\r\n钟莹, 陈祥献. 基于 XML 的虚拟仪器标记语言——VIML[J]. 仪器仪表学报, 2002, 3.\r\n姚屏. 基于 XML 的机械图形标记语言的研究与开发[D]. 长沙: 中南大学, 2005.\r\n附录A 攻读学位期间发表的学术论文与获得的成果\r\n湖南大学：并行编程助手软件V1.0.软件著作权.证书号：软著登字第4915889号.登记号：2020SR0037193.\r\n附录B 攻读学位期间参加的科研项目\r\n面向E级计算的能源勘探高性能应用软件系统与示范，项目号：2017YFB0202900.时间：2017.07-2021.06.\r\n致谢\r\n时光荏苒，随着毕业论文接近尾声，我三年的硕士生涯也将告一段落。在此，衷心地对我的母校，对给予我鼓励和帮助的老师、同学以及亲友表达诚挚的谢意。感谢你们陪伴着我一起度过的美好时光；感谢你们对我学习和生活的默默关怀；感谢你们一直激励着我奋力前行。\r\n感谢我的导师彭蔓蔓教授。彭老师品德高尚、治学严谨。在我三年的学习期间，为我提供了力所能及的帮助与支持。在本文研究课题的进行过程中，老师耐心地听取了我每次的进展报告，及时地提出了技术修改方案，传授了做学问的技巧，保证了本文的撰写工作顺利进行。感谢彭老师一直以来地信任和培养，学生当以您为榜样在学术和专业上不断奋斗。\r\n感谢朝夕相处的老师和同学们，感谢你们这些年来的关心，帮助和信任。在实验室的日子，是我学习生涯中最宝贵的财富。感谢读研期间你们同我一起坚持不懈的奋斗，无论炎夏还是寒冬。感谢吴强老师、申园园博士、黄流超同学和张凡同学，在团队合作中营造了良好的学术氛围，让我感受到了钻研学术的满足和快乐。感谢我的室友薛时雨同学和邹骁峰同学，感谢你们的包容和理解，让我在三年的校园生活中收获了难忘的室友情谊。\r\n感谢我的父母，二老多年来对我的支持与付出让我更有力量去面对一切困难。同时，我还要感谢女朋友雍晓光同学，纵使身在异地，也总是给与我及时的陪伴与鼓励，让我有源源不断的动力勇往直前。\r\n感谢我的母校湖南大学，给予了我丰富多彩的校园生活和宝贵的学习机会。有欢乐也有磨难，这段校园生活将成为我人生中一段难忘的过往。感谢母校以及信息科学与工程学院在我学习生涯中提供的宝贵资源，我将一直谨记校训，不忘初心，在今后的道路上砥砺前行。\r\n最后，衷心感谢各位老师和评审专家，感谢你们百忙之中抽出时间审阅本文并提出了宝贵意见，谢谢你们的辛勤工作和无私付出。\r\n王世领2020年4月";
        similarFragments = similarFragments.reverse();

        // bar2BeginPosition
        var bar2BeginPosition = htmlContent.length;

        _.forEach(similarFragments, function (similarFragment, index) {
            var article = data.recordList[similarFragment.recordIndex];

            var hasBanquan = true;
            var hasBanquanKV = _.find(article.dataBaseInfoMap, function (item) { return item.key == '有无版权' });
            if (!hasBanquanKV || hasBanquanKV.value != "1") {
                hasBanquan = false;
            }

            if (article.DBID == "报纸" || article.DBID == "专利") {
                hasBanquan = true;
            }

            similarFragment.hasBanquan = hasBanquan;

            // 判断类型
            var textClass =
                article.isReference ? 'text-reference' : (
                    article.isPublishedSelfCited ? 'text-published' : (
                        article.isUnPublishedSelfCited ? 'text-degree' : 'text-others'
                    ));

            if (article.isUnPublishedSelfCited) {
                if (isPublished) {
                    textClass = 'text-degree';
                }
                else {
                    textClass = 'text-others';
                }
            }

            var foo = htmlContent.substr(0, similarFragment.beginPosition);
            //var text = htmlContent.substr(similarFragment.beginPosition, similarFragment.length);
            text = getCharText(htmlContent, similarFragment, textClass);
            var bar = htmlContent.substring(similarFragment.beginPosition + similarFragment.length, bar2BeginPosition);
            var bar2 = htmlContent.substring(bar2BeginPosition);

            //
            //text = $("<div>").text(text).html();
            bar = $("<div>").text(bar).html();

            // 拼接
            htmlContent = foo + '<span data-index="' + similarFragment.index + '">' + text + suffix + bar + bar2;

            //similarFragment.fragmentPercent = (similarFragment.hitText.length / similarFragment.length * 100).toFixed(2);
            //similarFragment.hitText = similarFragment.hitText.replace(/\r\n/g, '<br />').replace(/\n/g, '<br />').replace(/\r/g, '<br />');

            // right
            similarFragment.hitText1 = "";
            for (var pos = 0; pos < similarFragment.hitLength; pos++) {
                if (similarFragment.similarChars.indexOf(similarFragment.hitBeginPosition + pos) != -1) {
                    similarFragment.hitText1 += '<span style="display:inline-block" class=text-others>' + similarFragment.hitText[pos] + '</span>';
                }
                else {
                    similarFragment.hitText1 += similarFragment.hitText[pos];
                }
            }
            similarFragment.hitText = similarFragment.hitText1.replace(/\r\n/g, '<br />').replace(/\n/g, '<br />').replace(/\r/g, '<br />');

            bar2BeginPosition = similarFragment.beginPosition;
        });
        similarFragments = similarFragments.reverse();

        htmlContent = htmlContent.replace(/\r\n/g, '<br />').replace(/\n/g, '<br />').replace(/\r/g, '<br />');

        $('#fulltext').html(htmlContent);

        $('#fulltext').on('click', 'span', function () {
            var fragment = $(this);

            var length = $(".text-highlight").length;
            if (length > 0) {
                $(".text-highlight").removeClass("text-highlight");
            }

            // 高亮
            fragment.addClass('text-highlight');

            var index = fragment.data('index');
            var similarFragment = similarFragments[index];
            viewModel.SimilarFragment(similarFragment);

        })
        //    .on('mouseout', 'span', function(){
        //    var fragment = $(this);

        //    // 高亮
        //    fragment.removeClass('text-highlight');
        //});


        function getCharText(content, similarFragment, textClass) {
            var positionArray = similarFragment.originalChars;

            var text = '';
            var flag = false;
            for (var i = similarFragment.beginPosition; i < similarFragment.beginPosition + similarFragment.length; i++) {
                if (positionArray.indexOf(i) != -1) {
                    if (flag == true) {
                        text += $("<div>").text(content[i]).html();
                    }
                    else {
                        text += '<span class="' + textClass + ' active" style="cursor:pointer;">' + $("<div>").text(content[i]).html();
                        flag = true;
                    }
                }
                else {
                    if (flag == true) {
                        text += '</span>' + $("<div>").text(content[i]).html();
                        flag = false;
                    }
                    else {
                        text += $("<div>").text(content[i]).html();
                    }
                }
            }

            if (flag == true) {
                text += '</span>';
            }

            similarFragment.originalChars.reverse();

            return text;
        }
    </script>


</body>
</html>